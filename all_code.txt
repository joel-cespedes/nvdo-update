---- src/index.html ----
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>NvdoUpdate</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
  <app-root></app-root>
</body>
</html>

---- src/app/app.component.html ----
<header class="app-header">
  <h1 class="app-header__title">Movesense Dashboard</h1>
</header>

<main class="app-main">
  <app-connection />

  <!-- Panel de Estado de Sensores -->
  <div class="sensor-panel">
    <h2 class="sensor-panel__title">Estado de Sensores</h2>
    <div class="sensor-panel__status-grid">
      <div class="sensor-status" [class.sensor-status--active]="temperatureStatus() === 'active'"
        [class.sensor-status--error]="temperatureStatus() === 'error'">
        <span class="sensor-status__name">Temperatura:</span>
        <span class="sensor-status__value">{{ temperatureStatus() }}</span>
      </div>
      <div class="sensor-status" [class.sensor-status--active]="accelerometerStatus() === 'active'"
        [class.sensor-status--error]="accelerometerStatus() === 'error'">
        <span class="sensor-status__name">Acelerómetro:</span>
        <span class="sensor-status__value">{{ accelerometerStatus() }}</span>
      </div>
      <div class="sensor-status" [class.sensor-status--active]="heartRateStatus() === 'active'"
        [class.sensor-status--error]="heartRateStatus() === 'error'">
        <span class="sensor-status__name">Ritmo Cardíaco:</span>
        <span class="sensor-status__value">{{ heartRateStatus() }}</span>
      </div>
      <div class="sensor-status" [class.sensor-status--active]="gyroscopeStatus() === 'active'"
        [class.sensor-status--error]="gyroscopeStatus() === 'error'">
        <span class="sensor-status__name">Giroscopio:</span>
        <span class="sensor-status__value">{{ gyroscopeStatus() }}</span>
      </div>
      <div class="sensor-status" [class.sensor-status--active]="magnetometerStatus() === 'active'"
        [class.sensor-status--error]="magnetometerStatus() === 'error'">
        <span class="sensor-status__name">Magnetómetro:</span>
        <span class="sensor-status__value">{{ magnetometerStatus() }}</span>
      </div>
      <div class="sensor-status" [class.sensor-status--active]="ecgStatus() === 'active'"
        [class.sensor-status--error]="ecgStatus() === 'error'">
        <span class="sensor-status__name">ECG:</span>
        <span class="sensor-status__value">{{ ecgStatus() }}</span>
      </div>

    </div>
  </div>

  <!-- Métricas Calculadas -->
  <app-metrics-display />

  <!-- Visualizaciones de Datos de Sensores -->
  <div class="sensor-data-area">
    <app-temperature-display />
    <app-hr-chart />
    <app-acc-chart />
          <app-memory-recording />
    <app-ecg-chart />
    <app-gyro-display />
    <app-magn-display />
  </div>

  <!-- ECGs Guardados -->
  @if (hasStoredEcgs()) {
  <app-stored-ecg-list class="stored-ecg-section" />
  }
  @if (hasStoredMemoryRecordings()) {
  <app-memory-recording-list class="stored-memory-section" />
  }

  <router-outlet />
</main>

<footer class="app-footer">
  <p class="app-footer__text">Movesense Angular App</p>
</footer>
---- src/app/core/models/memory-recording.model.ts ----
export interface StoredMemoryRecording {
    id: string;
    timestamp: number;
    duration: number;
    name?: string;
    sensorData: {
        accelerometer?: number[][];
        temperature?: number[];
        heartRate?: number[];
        gyroscope?: number[][];
        magnetometer?: number[][];
        ecg?: number[];
    };
}
---- src/app/core/models/movesense-ble.model.ts ----
export const MOVESENSE_BLE = {
    SERVICE_UUID: '34802252-7185-4d5d-b431-630e7050e8f0',
    CHAR_COMMAND_UUID: '34800001-7185-4d5d-b431-630e7050e8f0', // Write
    CHAR_NOTIFY_UUID: '34800002-7185-4d5d-b431-630e7050e8f0',  // Notify
};

export const MOVESENSE_METHOD = {
    GET: 0x01,
    PUT: 0x02,
    POST: 0x03,
    DELETE: 0x04,
    SUBSCRIBE: 0x0c,
    UNSUBSCRIBE: 0x00
};

export function createMovesenseCommand(method: number, path: string): Uint8Array {
    const pathBytes = new TextEncoder().encode(path);
    const command = new Uint8Array(pathBytes.length + 1);
    command[0] = method;
    command.set(pathBytes, 1);
    return command;
}
---- src/app/core/models/ecg-storage.model.ts ----

export interface StoredEcg {
    id: string;
    timestamp: number;
    samples: number[];
    duration: number; // Duración en segundos
    name?: string;    // Nombre opcional para el registro
}
---- src/app/core/models/sensor-data.model.ts ----
export interface AccelerometerData {
    timestamp: number;
    x: number;
    y: number;
    z: number;
    magnitude: number;
    samples?: { x: number; y: number; z: number }[];
}

export interface TemperatureData {
    timestamp: number;
    measurement: number; // En Celsius
}

export interface HeartRateData {
    timestamp: number;
    hr: number; // Promedio HR (BPM)
    rrIntervals?: number[]; // Intervalos RR en ms
}

export interface EcgData {
    timestamp: number;
    samples: number[];
}

export interface GyroscopeData {
    timestamp: number;
    samples: { x: number; y: number; z: number }[];
}

export interface MagnetometerData {
    timestamp: number;
    samples: { x: number; y: number; z: number }[];
}

export type SensorStatus = 'inactive' | 'active' | 'error';

export enum PostureState {
    UNKNOWN = 'unknown',
    STANDING = 'standing',
    STOOPED = 'stooped',
    LYING = 'lying'
}

// Constantes para límites de sensores - importante para validación
export const SENSOR_LIMITS = {
    HR_MIN: 40,
    HR_MAX: 200,
    TEMP_MIN: 0,
    TEMP_MAX: 50,
    ACC_MAX: 20, // Valor típico para acelerómetro en m/s²
};
---- src/app/core/models/movesense-commands.model.ts ----
export const MOVESENSE_COMMANDS = {
    // Comandos para sensores
    TEMPERATURE: new Uint8Array([0x01, 0x62, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x54, 0x65, 0x6d, 0x70]),
    ACCELEROMETER: new Uint8Array([0x0c, 0x62, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x41, 0x63, 0x63, 0x2f, 0x31, 0x30, 0x34]),
    HEART_RATE: new Uint8Array([0x0c, 0x63, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x48, 0x52]),
    ECG: new Uint8Array([0x01, 0x63, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x45, 0x43, 0x47, 0x2f, 0x31, 0x32, 0x35]),
    GYROSCOPE: new Uint8Array([0x0c, 0x64, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x47, 0x79, 0x72, 0x6f, 0x2f, 0x31, 0x30, 0x34]),
    MAGNETOMETER: new Uint8Array([0x0c, 0x65, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x4d, 0x61, 0x67, 0x6e, 0x2f, 0x31, 0x30, 0x34]),

    // Comandos para detener sensores
    STOP_TEMP: new Uint8Array([0x00, 0x62, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x54, 0x65, 0x6d, 0x70]),
    STOP_ACC: new Uint8Array([0x00, 0x62, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x41, 0x63, 0x63]),
    STOP_HR: new Uint8Array([0x00, 0x63, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x48, 0x52]),
    STOP_GYRO: new Uint8Array([0x00, 0x64, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x47, 0x79, 0x72, 0x6f]),
    STOP_MAGN: new Uint8Array([0x00, 0x65, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x4d, 0x61, 0x67, 0x6e]),
    STOP_ECG: new Uint8Array([0x00, 0x63, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x45, 0x43, 0x47]),

    // Comandos de memoria
    START_MEMORY: new Uint8Array([0x05]),
    STOP_MEMORY: new Uint8Array([0x06, 0x65, 0x01, 0x00, 0x00, 0x00]),
};

// Mapa de tipos de sensores para facilitar la lógica
export const SENSOR_TYPES = {
    TEMPERATURE: 'temperature',
    ACCELEROMETER: 'accelerometer',
    HEART_RATE: 'heartRate',
    ECG: 'ecg',
    GYROSCOPE: 'gyroscope',
    MAGNETOMETER: 'magnetometer'
};

// Constantes para interpretación de datos
export const DATA_CONSTANTS = {
    ECG_SAMPLE_RATE: 128, // Hz
    ACCELEROMETER_SCALE: 16, // Para normalizar valores
    GYROSCOPE_SCALE: 2, // Para interpretar valores en °/s
    MAGNETOMETER_SCALE: 2 // Para interpretar valores en μT
};
---- src/app/core/services/activity-data-processor.service.ts ----
import { Injectable, signal } from '@angular/core';
import { PostureState } from '../models/sensor-data.model';

@Injectable({
    providedIn: 'root',
})
export class ActivityDataProcessorService {
    // Señales métricas
    readonly steps = signal<number>(0);
    readonly distance = signal<number>(0);
    readonly posture = signal<PostureState>(PostureState.UNKNOWN);
    readonly hrvRmssd = signal<number | null>(null);
    readonly stressLevel = signal<number | null>(null);
    readonly dribbleCount = signal<number>(0);
    readonly caloriesBurned = signal<number>(0);
    readonly fallDetected = signal<boolean>(false);
    readonly lastFallTimestamp = signal<number | null>(null);

    // Variables de seguimiento
    private _rrHistory: number[] = [];
    private _lastStepTimestamp = 0;
    private _gravity = { x: 0, y: 0, z: 0 };
    private _isFirstAccSample = true;
    private _lastDribbleTimestamp = 0;
    private _activityStartTime = 0;

    // Constantes de configuración
    private readonly STEP_THRESHOLD = 0.5;
    private readonly STEP_COOLDOWN = 350; // ms
    private readonly DRIBBLE_THRESHOLD = 1.8;
    private readonly DRIBBLE_COOLDOWN = 150; // ms
    private readonly FALL_THRESHOLD = 2.5;
    private readonly FALL_WINDOW = 1000; // ms

    /**
     * Procesa una muestra del acelerómetro
     */
    processAccelSample(x: number, y: number, z: number): void {
        // Calcular vector de gravedad con filtro pasa-bajo
        if (this._isFirstAccSample) {
            this._gravity = { x, y, z };
            this._isFirstAccSample = false;
        } else {
            const alpha = 0.1; // Factor de filtrado
            this._gravity.x = this._gravity.x * (1 - alpha) + x * alpha;
            this._gravity.y = this._gravity.y * (1 - alpha) + y * alpha;
            this._gravity.z = this._gravity.z * (1 - alpha) + z * alpha;
        }

        // Calcular aceleración lineal (sin gravedad)
        const linearAccX = x - this._gravity.x;
        const linearAccY = y - this._gravity.y;
        const linearAccZ = z - this._gravity.z;

        // Calcular magnitud de aceleración
        const magnitude = Math.sqrt(
            Math.pow(linearAccX, 2) +
            Math.pow(linearAccY, 2) +
            Math.pow(linearAccZ, 2)
        );

        const now = Date.now();

        // Detección de pasos
        if (magnitude > this.STEP_THRESHOLD && (now - this._lastStepTimestamp) > this.STEP_COOLDOWN) {
            this._lastStepTimestamp = now;
            this.steps.update(steps => steps + 1);
            // Incrementar distancia (0.7m por paso es un valor aproximado)
            this.distance.update(distance => distance + 0.7);
        }

        // Detección de regates (para aplicaciones deportivas)
        if (magnitude > this.DRIBBLE_THRESHOLD && (now - this._lastDribbleTimestamp) > this.DRIBBLE_COOLDOWN) {
            this._lastDribbleTimestamp = now;
            this.dribbleCount.update(count => count + 1);
        }

        // Análisis de postura basado en el ángulo vertical
        const verticalAngle = Math.atan2(
            Math.sqrt(this._gravity.x * this._gravity.x + this._gravity.y * this._gravity.y),
            this._gravity.z
        ) * (180 / Math.PI);

        // Clasificación de postura
        const newPosture = verticalAngle < 30
            ? PostureState.STANDING
            : verticalAngle < 75
                ? PostureState.STOOPED
                : PostureState.LYING;

        this.posture.set(newPosture);

        // Detección de caídas
        if (magnitude > this.FALL_THRESHOLD) {
            const currentTime = Date.now();
            this.fallDetected.set(true);
            this.lastFallTimestamp.set(currentTime);

            // Restablecer estado de caída después de un tiempo
            setTimeout(() => {
                if (this.lastFallTimestamp() === currentTime) {
                    this.fallDetected.set(false);
                }
            }, this.FALL_WINDOW);
        }
    }

    /**
     * Actualiza las calorías quemadas basadas en el ritmo cardíaco
     */
    updateCalories(heartRate: number): void {
        if (!heartRate || heartRate < 40 || heartRate > 240) return;

        if (this._activityStartTime === 0) {
            this._activityStartTime = Date.now();
        }

        // Duración de la actividad en horas
        const activityDurationHours = (Date.now() - this._activityStartTime) / 3600000;

        // Parámetros del usuario (valores medios por defecto)
        const weight = 70; // kg
        const age = 30; // años
        const isMale = true;

        const gender = isMale ? 1 : 0;

        // Fórmula para calorías por minuto basada en HR
        const caloriesPerMinute = ((-55.0969 + (0.6309 * heartRate) +
            (0.1988 * weight) + (0.2017 * age)) / 4.184) *
            (gender ? 1 : 0.85);

        // Calorías totales
        const totalCalories = caloriesPerMinute * (activityDurationHours * 60);

        this.caloriesBurned.set(Math.round(totalCalories));
    }

    /**
     * Inicia una nueva actividad
     */
    startActivity(): void {
        this._activityStartTime = Date.now();
        this.resetActivityData();
    }

    /**
     * Resetea datos de actividad
     */
    resetActivityData(): void {
        this.steps.set(0);
        this.distance.set(0);
        this.posture.set(PostureState.UNKNOWN);
        this.hrvRmssd.set(null);
        this.stressLevel.set(null);
        this.dribbleCount.set(0);
        this.caloriesBurned.set(0);
        this.fallDetected.set(false);
        this.lastFallTimestamp.set(null);

        this._rrHistory = [];
        this._lastStepTimestamp = 0;
        this._gravity = { x: 0, y: 0, z: 0 };
        this._isFirstAccSample = true;
        this._lastDribbleTimestamp = 0;
        this._activityStartTime = Date.now();
    }
}
---- src/app/core/services/ecg-storage.service.ts ----
import { Injectable, Signal, computed, signal } from '@angular/core';
import { StoredEcg } from '../models/ecg-storage.model';
import { DATA_CONSTANTS } from '../models/movesense-commands.model';


const STORAGE_KEY = 'movesense_ecg_records';

@Injectable({
    providedIn: 'root',
})
export class EcgStorageService {
    private storedEcgsSignal = signal<StoredEcg[]>([]);

    readonly storedEcgs: Signal<StoredEcg[]> = this.storedEcgsSignal.asReadonly();
    readonly hasStoredEcgs = computed(() => this.storedEcgsSignal().length > 0);

    constructor() {
        this.loadFromStorage();
    }

    /**
     * Guarda un nuevo ECG
     * @param samples Muestras de ECG
     * @param timestamp Timestamp de la grabación
     * @returns ID del ECG guardado
     */
    saveEcg(samples: number[], timestamp = Date.now()): string {
        const id = crypto.randomUUID();
        const duration = samples.length / DATA_CONSTANTS.ECG_SAMPLE_RATE;

        const newEcg: StoredEcg = {
            id,
            timestamp,
            samples,
            duration
        };

        console.log(`Guardando ECG en almacenamiento: ${samples.length} muestras, duración: ${duration.toFixed(2)}s`);

        this.storedEcgsSignal.update(ecgs => [newEcg, ...ecgs]);

        try {
            this.saveToStorage();
            console.log('ECG guardado con éxito en localStorage');
        } catch (error) {
            console.error('Error al guardar en localStorage:', error);

            // Manejo de error de almacenamiento
            if (error instanceof DOMException && error.name === 'QuotaExceededError') {
                console.warn('localStorage lleno, reduciendo tamaño de muestras ECG');
                this.reduceStoredSamplesSize();
            }
        }

        return id;
    }

    /**
     * Reduce el tamaño de las muestras almacenadas cuando hay error de cuota
     */
    private reduceStoredSamplesSize(): void {
        // Reducir el tamaño de las muestras de cada ECG
        const limitedEcgs = this.storedEcgsSignal().map(ecg => {
            if (ecg.samples.length > 2000) {
                return {
                    ...ecg,
                    samples: ecg.samples.slice(0, 2000),
                    duration: 2000 / DATA_CONSTANTS.ECG_SAMPLE_RATE
                };
            }
            return ecg;
        });

        // Si aún tenemos muchos ECGs, conservar solo los más recientes
        if (limitedEcgs.length > 10) {
            const reducedEcgs = limitedEcgs
                .sort((a, b) => b.timestamp - a.timestamp)
                .slice(0, 10);

            this.storedEcgsSignal.set(reducedEcgs);
        } else {
            this.storedEcgsSignal.set(limitedEcgs);
        }

        // Intentar guardar nuevamente
        try {
            const reducedData = JSON.stringify(this.storedEcgsSignal());
            localStorage.setItem(STORAGE_KEY, reducedData);
            console.log('ECG guardado con muestras reducidas');
        } catch (e) {
            console.error('Error guardando incluso con datos reducidos:', e);
        }
    }

    /**
     * Elimina un ECG por su ID
     */
    deleteEcg(id: string): boolean {
        const currentEcgs = this.storedEcgsSignal();
        const initialLength = currentEcgs.length;

        this.storedEcgsSignal.update(ecgs => ecgs.filter(ecg => ecg.id !== id));

        if (currentEcgs.length !== initialLength) {
            this.saveToStorage();
            return true;
        }

        return false;
    }

    /**
     * Renombra un ECG
     */
    renameEcg(id: string, name: string): boolean {
        let found = false;

        this.storedEcgsSignal.update(ecgs => {
            return ecgs.map(ecg => {
                if (ecg.id === id) {
                    found = true;
                    return { ...ecg, name };
                }
                return ecg;
            });
        });

        if (found) {
            this.saveToStorage();
        }

        return found;
    }

    /**
     * Obtiene un ECG por su ID
     */
    getEcgById(id: string): StoredEcg | undefined {
        return this.storedEcgsSignal().find(ecg => ecg.id === id);
    }

    /**
     * Carga los ECGs desde el almacenamiento local
     */
    private loadFromStorage(): void {
        try {
            const storedData = localStorage.getItem(STORAGE_KEY);
            if (storedData) {
                const parsedData = JSON.parse(storedData) as StoredEcg[];
                this.storedEcgsSignal.set(parsedData);
            }
        } catch (error) {
            console.error('Error cargando datos ECG desde almacenamiento:', error);
        }
    }

    /**
     * Guarda los ECGs en el almacenamiento local
     */
    private saveToStorage(): void {
        try {
            const dataToStore = JSON.stringify(this.storedEcgsSignal());
            localStorage.setItem(STORAGE_KEY, dataToStore);
        } catch (error) {
            console.error('Error guardando datos ECG en almacenamiento:', error);

            if (error instanceof DOMException && error.name === 'QuotaExceededError') {
                this.handleStorageQuotaExceeded();
            }
        }
    }

    /**
     * Maneja el error de cuota excedida en localStorage
     */
    private handleStorageQuotaExceeded(): void {
        console.warn('localStorage lleno, limitando muestras ECG');

        // Reducir el tamaño de las muestras de cada ECG
        const limitedEcgs = this.storedEcgsSignal().map(ecg => {
            if (ecg.samples.length > 2000) {
                return {
                    ...ecg,
                    samples: ecg.samples.slice(0, 2000),
                    duration: 2000 / DATA_CONSTANTS.ECG_SAMPLE_RATE
                };
            }
            return ecg;
        });

        // Si aún tenemos muchos ECGs, conservar solo los más recientes
        if (limitedEcgs.length > 10) {
            const reducedEcgs = limitedEcgs
                .sort((a, b) => b.timestamp - a.timestamp)
                .slice(0, 10);

            this.storedEcgsSignal.set(reducedEcgs);
        } else {
            this.storedEcgsSignal.set(limitedEcgs);
        }

        // Intentar guardar nuevamente
        try {
            const reducedData = JSON.stringify(this.storedEcgsSignal());
            localStorage.setItem(STORAGE_KEY, reducedData);
        } catch (e) {
            console.error('Error guardando incluso con datos reducidos:', e);
        }
    }

    /**
     * Limpia todos los ECGs
     */
    clearAll(): void {
        this.storedEcgsSignal.set([]);
        localStorage.removeItem(STORAGE_KEY);
    }
}
---- src/app/core/services/movesense-connection.service.ts ----
import { Injectable, signal } from '@angular/core';
import { MOVESENSE_BLE, MOVESENSE_METHOD, createMovesenseCommand } from '../models/movesense-ble.model';
import { MOVESENSE_COMMANDS } from '../models/movesense-commands.model';

export interface CommandQueueItem {
    command: Uint8Array;
    description: string;
    priority?: number;
}

@Injectable({
    providedIn: 'root',
})
export class MovesenseConnectionService {
    // Estado de conexión
    readonly isConnected = signal<boolean>(false);
    readonly deviceName = signal<string>('');
    readonly connectionError = signal<string | null>(null);
    readonly reconnectAttempts = signal<number>(0);
    readonly batteryLevel = signal<number | null>(null);

    // Bluetooth API
    private bleServer: BluetoothRemoteGATTServer | null = null;
    private commandChar: BluetoothRemoteGATTCharacteristic | null = null;
    private notifyChar: BluetoothRemoteGATTCharacteristic | null = null;
    private device: BluetoothDevice | null = null;

    // Manejadores
    private notificationHandler: ((event: Event) => void) | null = null;
    private memoryDataCallback: ((data: Uint8Array) => void) | null = null;

    // Cola de comandos
    private commandQueue: CommandQueueItem[] = [];
    private isProcessingQueue = false;
    private lastCommandTime = 0;
    private readonly COMMAND_INTERVAL = 200; // ms entre comandos

    // Reconexión
    private reconnectTimer: number | null = null;
    private maxReconnectAttempts = 3;
    private intentionalDisconnect = false;

    /**
     * Inicia la conexión BLE con un dispositivo Movesense
     */
    async connect(): Promise<void> {
        this.connectionError.set(null);
        this.resetReconnectAttempts();

        try {
            this.device = await navigator.bluetooth.requestDevice({
                filters: [{ namePrefix: 'Movesense' }],
                optionalServices: [MOVESENSE_BLE.SERVICE_UUID],
            });

            if (!this.device.gatt) {
                throw new Error('GATT Server no disponible');
            }

            this.deviceName.set(this.device.name || 'Dispositivo Movesense');
            this.device.addEventListener('gattserverdisconnected', this.handleDisconnect.bind(this));

            this.bleServer = await this.device.gatt.connect();

            const service = await this.bleServer.getPrimaryService(MOVESENSE_BLE.SERVICE_UUID);
            this.commandChar = await service.getCharacteristic(MOVESENSE_BLE.CHAR_COMMAND_UUID);
            this.notifyChar = await service.getCharacteristic(MOVESENSE_BLE.CHAR_NOTIFY_UUID);

            await this.notifyChar.startNotifications();
            this.isConnected.set(true);

            // Solicitar información básica del dispositivo
            this.requestDeviceInfo();

        } catch (error) {
            this.handleConnectionError(error);
        }
    }

    /**
     * Desconecta del dispositivo Movesense
     */
    async disconnect(): Promise<void> {
        if (!this.bleServer || !this.isConnected()) {
            return;
        }

        this.clearReconnectTimer();
        this.intentionalDisconnect = true;
        this.bleServer.disconnect();

        // Resetear estado después de desconexión
        setTimeout(() => {
            this.resetState();
            this.intentionalDisconnect = false;
        }, 500);
    }

    /**
     * Registra el callback para datos de memoria
     */
    setMemoryDataCallback(callback: (data: Uint8Array) => void): void {
        this.memoryDataCallback = callback;
    }

    /**
     * Registra el manejador para notificaciones
     */
    registerNotificationHandler(handler: (event: Event) => void): void {
        if (!this.notifyChar || !this.isConnected()) {
            return;
        }

        this.unregisterNotificationHandler();
        this.notificationHandler = handler;
        this.notifyChar.addEventListener('characteristicvaluechanged', this.handleNotifications.bind(this));
    }

    /**
    * Procesa notificaciones entrantes del dispositivo BLE
    */
    private handleNotifications(event: Event): void {
        try {
            const characteristic = (event.target as BluetoothRemoteGATTCharacteristic);
            const dataView = characteristic.value;

            if (!dataView) return;

            const data = new Uint8Array(dataView.buffer);
            if (data.length === 0) return;

            // Detectar si es una respuesta de memoria
            const isMemoryData = this.isMemoryData(data);

            if (isMemoryData && this.memoryDataCallback) {
                // Si es dato de memoria y hay callback configurado, enviarlo allí
                this.memoryDataCallback(data);
            } else if (this.notificationHandler) {
                // Para el resto de datos, usar el manejador general
                this.notificationHandler(event);
            }
        } catch (error) {
            console.error('Error en handleNotifications:', error);
        }
    }

    /**
     * Determina si los datos son de memoria
     */
    private isMemoryData(data: Uint8Array): boolean {
        // Ignorar respuestas "Hello"
        if (data.length === 7 && data[2] === 72) {
            return false;
        }

        // Verificar si son datos de memoria
        if (data.length > 5) {
            if (data[0] === 0x02 || data[0] === 0x03 || data[0] === 0x06) {
                return true;
            }

            if (data[0] === 0x01 && data[1] === 0x2F && data[2] === 0x4D &&
                data[3] === 0x65 && data[4] === 0x6D) {
                return true;
            }
        }

        return false;
    }

    /**
     * Elimina el manejador de notificaciones
     */
    unregisterNotificationHandler(): void {
        if (this.notifyChar && this.notificationHandler) {
            try {
                this.notifyChar.removeEventListener(
                    'characteristicvaluechanged',
                    this.handleNotifications.bind(this)
                );
            } catch (e) {
                // Error silencioso al quitar listener
            }
            this.notificationHandler = null;
        }
    }

    /**
     * Envía un comando al dispositivo
     */
    sendCommandRaw(commandData: Uint8Array, commandDescription: string, priority = 0): void {
        this.enqueueCommand({
            command: commandData,
            description: commandDescription,
            priority
        });
    }

    /**
     * Envía un comando REST al dispositivo
     */
    sendRestCommand(method: number, path: string, description: string): void {
        const command = createMovesenseCommand(method, path);
        this.sendCommandRaw(command, description);
    }

    /**
     * Suscribe a todos los sensores
     */
    subscribeToSensors(): void {
        if (!this.isConnected()) {
            return;
        }

        // Primero detener todas las mediciones
        this.sendCommandRaw(MOVESENSE_COMMANDS.STOP_TEMP, 'Stop Temperature', 1);
        this.sendCommandRaw(MOVESENSE_COMMANDS.STOP_ACC, 'Stop Accelerometer', 1);
        this.sendCommandRaw(MOVESENSE_COMMANDS.STOP_HR, 'Stop Heart Rate', 1);
        this.sendCommandRaw(MOVESENSE_COMMANDS.STOP_GYRO, 'Stop Gyroscope', 1);
        this.sendCommandRaw(MOVESENSE_COMMANDS.STOP_MAGN, 'Stop Magnetometer', 1);
        this.sendCommandRaw(MOVESENSE_COMMANDS.STOP_ECG, 'Stop ECG', 1);

        // Luego iniciar con un ligero retraso
        setTimeout(() => {
            this.sendCommandRaw(MOVESENSE_COMMANDS.TEMPERATURE, 'Temperature sensor');
            this.sendCommandRaw(MOVESENSE_COMMANDS.ACCELEROMETER, 'Accelerometer sensor');
            this.sendCommandRaw(MOVESENSE_COMMANDS.HEART_RATE, 'Heart rate sensor');
            this.sendCommandRaw(MOVESENSE_COMMANDS.GYROSCOPE, 'Gyroscope sensor');
            this.sendCommandRaw(MOVESENSE_COMMANDS.MAGNETOMETER, 'Magnetometer sensor');
            this.sendCommandRaw(MOVESENSE_COMMANDS.ECG, 'ECG sensor');
        }, 1000);
    }

    /**
     * Solicita información del dispositivo
     */
    requestDeviceInfo(): void {
        if (!this.isConnected()) {
            return;
        }

        this.sendRestCommand(MOVESENSE_METHOD.GET, '/System/Info', 'Device Info');
        this.sendRestCommand(MOVESENSE_METHOD.GET, '/System/Energy/Level', 'Battery Level');
        this.sendRestCommand(MOVESENSE_METHOD.GET, '/System/Sensors', 'Available Sensors');
    }

    /**
     * Añade un comando a la cola
     */
    private enqueueCommand(item: CommandQueueItem): void {
        // Si tiene prioridad alta, ponerlo al principio
        if (item.priority && item.priority > 0) {
            this.commandQueue.unshift(item);
        } else {
            this.commandQueue.push(item);
        }
        this.processCommandQueue();
    }

    /**
     * Procesa la cola de comandos
     */
    private async processCommandQueue(): Promise<void> {
        if (this.isProcessingQueue || this.commandQueue.length === 0 || !this.isConnected()) {
            return;
        }

        this.isProcessingQueue = true;

        try {
            // Esperar el intervalo correcto entre comandos
            const now = Date.now();
            const timeSinceLastCommand = now - this.lastCommandTime;

            if (timeSinceLastCommand < this.COMMAND_INTERVAL) {
                await new Promise(resolve =>
                    setTimeout(resolve, this.COMMAND_INTERVAL - timeSinceLastCommand)
                );
            }

            const { command, description } = this.commandQueue.shift()!;
            await this.sendCommandDirectly(command, description);
            this.lastCommandTime = Date.now();

        } catch (error) {
            console.error('Error enviando comando:', error);
        } finally {
            this.isProcessingQueue = false;

            // Continuar procesando la cola si hay más comandos
            if (this.commandQueue.length > 0) {
                setTimeout(() => this.processCommandQueue(), 50);
            }
        }
    }

    /**
     * Envía un comando directamente al dispositivo
     */
    private async sendCommandDirectly(commandData: Uint8Array, commandDescription: string): Promise<void> {
        if (!this.commandChar || !this.isConnected()) {
            return Promise.reject('Dispositivo no conectado');
        }

        try {
            await this.commandChar.writeValue(commandData);
            console.log(`✅ Comando enviado: ${commandDescription}`);
        } catch (error) {
            console.error(`❌ Error enviando comando: ${commandDescription}`, error);
            throw error;
        }
    }

    /**
     * Maneja la desconexión del dispositivo
     */
    private handleDisconnect(_event: Event): void {
        if (this.intentionalDisconnect) {
            this.resetState();
            return;
        }

        if (this.isConnected() && this.reconnectAttempts() < this.maxReconnectAttempts) {
            this.reconnectAttempts.update(attempts => attempts + 1);

            this.clearReconnectTimer();
            this.reconnectTimer = window.setTimeout(() => {
                this.attemptReconnect();
            }, 2000);
        } else {
            this.resetState();
        }
    }

    /**
     * Intenta reconectar con el dispositivo
     */
    private async attemptReconnect(): Promise<void> {
        if (!this.device || !this.device.gatt) {
            this.resetState();
            return;
        }

        try {
            console.log(`Intento de reconexión ${this.reconnectAttempts()} de ${this.maxReconnectAttempts}`);

            this.bleServer = await this.device.gatt.connect();
            const service = await this.bleServer.getPrimaryService(MOVESENSE_BLE.SERVICE_UUID);
            this.commandChar = await service.getCharacteristic(MOVESENSE_BLE.CHAR_COMMAND_UUID);
            this.notifyChar = await service.getCharacteristic(MOVESENSE_BLE.CHAR_NOTIFY_UUID);
            await this.notifyChar.startNotifications();

            this.isConnected.set(true);
            this.reconnectAttempts.set(0);
            console.log('Reconexión exitosa');

        } catch (error) {
            console.error('Error en reconexión:', error);

            if (this.reconnectAttempts() < this.maxReconnectAttempts) {
                this.clearReconnectTimer();
                this.reconnectTimer = window.setTimeout(() => {
                    this.attemptReconnect();
                }, 3000);
            } else {
                console.log('Máximo de intentos de reconexión alcanzado');
                this.resetState();
            }
        }
    }

    /**
     * Resetea los intentos de reconexión
     */
    private resetReconnectAttempts(): void {
        this.reconnectAttempts.set(0);
        this.clearReconnectTimer();
    }

    /**
     * Limpia el temporizador de reconexión
     */
    private clearReconnectTimer(): void {
        if (this.reconnectTimer !== null) {
            window.clearTimeout(this.reconnectTimer);
            this.reconnectTimer = null;
        }
    }

    /**
     * Maneja errores de conexión
     */
    private handleConnectionError(error: any): void {
        const errorMessage = error instanceof Error ? error.message : String(error);
        this.connectionError.set(errorMessage);
        this.isConnected.set(false);
        this.resetState();
    }

    /**
     * Resetea el estado de la conexión
     */
    private resetState(): void {
        this.isConnected.set(false);
        this.deviceName.set('');
        this.bleServer = null;
        this.device = null;

        this.unregisterNotificationHandler();

        this.notifyChar = null;
        this.commandChar = null;
        this.notificationHandler = null;
        this.commandQueue = [];
        this.isProcessingQueue = false;

        this.clearReconnectTimer();
    }
}
---- src/app/core/services/movesense.service.ts ----
import { effect, computed, inject, Injectable, linkedSignal, signal } from '@angular/core';
import { MovesenseConnectionService } from './movesense-connection.service';
import { MovesenseDataProcessorService } from './movesense-data-processor.service';
import { EcgStorageService } from './ecg-storage.service';
import { MemoryStorageService } from './memory-storage.service';
import { MOVESENSE_COMMANDS } from '../models/movesense-commands.model';
import { StoredMemoryRecording } from '../models/memory-recording.model';
import { DATA_CONSTANTS } from '../models/movesense-commands.model';
import { ActivityDataProcessorService } from './activity-data-processor.service';

@Injectable({
    providedIn: 'root',
})
export class MovesenseService {
    private connectionService = inject(MovesenseConnectionService);
    private dataProcessor = inject(MovesenseDataProcessorService);
    private ecgStorage = inject(EcgStorageService);
    private activityProcessor = inject(ActivityDataProcessorService);
    private memoryStorage = inject(MemoryStorageService);

    // Estado de descarga de memoria
    readonly bytesDownloaded = signal<number>(0);

    // Temporizadores y estado de memoria
    private logbookTimeoutId: ReturnType<typeof setTimeout> | null = null;
    private sensorMonitorTimer: number | null = null;
    private processedLogbookNotifications = new Set<string>();
    private isProcessingLogbook = false;
    private _memoryData: DataView | null = null;

    // Conexión y estado de dispositivo
    readonly isConnected = linkedSignal(this.connectionService.isConnected);
    readonly deviceName = linkedSignal(this.connectionService.deviceName);
    readonly connectionError = linkedSignal(this.connectionService.connectionError);

    // Datos de sensores
    readonly temperatureData = linkedSignal(this.dataProcessor.temperatureData);
    readonly accelerometerData = linkedSignal(this.dataProcessor.accelerometerData);
    readonly heartRateData = linkedSignal(this.dataProcessor.heartRateData);
    readonly ecgData = linkedSignal(this.dataProcessor.ecgData);
    readonly gyroscopeData = linkedSignal(this.dataProcessor.gyroscopeData);
    readonly magnetometerData = linkedSignal(this.dataProcessor.magnetometerData);

    // Estado de sensores
    readonly temperatureStatus = linkedSignal(this.dataProcessor.temperatureStatus);
    readonly accelerometerStatus = linkedSignal(this.dataProcessor.accelerometerStatus);
    readonly heartRateStatus = linkedSignal(this.dataProcessor.heartRateStatus);
    readonly gyroscopeStatus = linkedSignal(this.dataProcessor.gyroscopeStatus);
    readonly magnetometerStatus = linkedSignal(this.dataProcessor.magnetometerStatus);
    readonly ecgStatus = linkedSignal(this.dataProcessor.ecgStatus);

    // Métricas de actividad
    readonly steps = linkedSignal(this.dataProcessor.steps);
    readonly distance = linkedSignal(this.dataProcessor.distance);
    readonly posture = linkedSignal(this.dataProcessor.posture);
    readonly hrvRmssd = linkedSignal(this.dataProcessor.hrvRmssd);
    readonly stressLevel = linkedSignal(this.dataProcessor.stressLevel);
    readonly dribbleCount = linkedSignal(this.dataProcessor.dribbleCount);
    readonly caloriesBurned = linkedSignal(this.dataProcessor.caloriesBurned);
    readonly fallDetected = linkedSignal(this.dataProcessor.fallDetected);
    readonly lastFallTimestamp = linkedSignal(this.dataProcessor.lastFallTimestamp);

    // Estado de grabación ECG
    readonly isEcgRecording = linkedSignal(this.dataProcessor.isEcgRecording);
    readonly recordedEcgSamples = linkedSignal(this.dataProcessor.recordedEcgSamples);

    // ECGs almacenados
    readonly storedEcgs = linkedSignal(this.ecgStorage.storedEcgs);
    readonly hasStoredEcgs = linkedSignal(this.ecgStorage.hasStoredEcgs);

    // Estado de grabación en memoria
    readonly isMemoryRecording = signal<boolean>(false);
    readonly memoryRecordingStatus = signal<string>('inactive');
    readonly storedMemoryRecordings = linkedSignal(this.memoryStorage.storedRecordingsSignal.asReadonly());
    readonly hasStoredMemoryRecordings = linkedSignal(this.memoryStorage.hasStoredRecordings);

    constructor() {
        // Registrar callback para datos de memoria
        this.connectionService.setMemoryDataCallback(this.handleMemoryData.bind(this));

        // Efecto para monitorear la conexión
        effect(() => {
            if (this.isConnected()) {
                this.setupSensorMonitoring();
            } else {
                this.clearSensorMonitoring();
            }
        });
    }

    /**
      * Conectar con el dispositivo Movesense
      */
    async connect(): Promise<void> {
        try {
            await this.connectionService.connect();

            if (this.isConnected()) {
                this.connectionService.registerNotificationHandler(this.handleNotification.bind(this));
                this.activityProcessor.startActivity(); // Usamos directamente el servicio inyectado
                this.subscribeToSensors();
            }
        } catch (error) {
            console.error('Error conectando con el dispositivo Movesense:', error);
        }
    }

    /**
     * Desconectar del dispositivo
     */
    async disconnect(): Promise<void> {
        await this.connectionService.disconnect();
    }

    /**
     * Suscribirse a todos los sensores
     */
    subscribeToSensors(): void {
        if (!this.isConnected()) return;
        this.connectionService.subscribeToSensors();
    }
    /**
     * Iniciar grabación de ECG para uso médico
     * Sigue protocolos estrictos para captura de datos clínicos
     */
    startEcgRecording(): void {
        console.log('Iniciando grabación de ECG médico');

        // Detener cualquier suscripción ECG previa para limpiar estado
        this.connectionService.sendCommandRaw(MOVESENSE_COMMANDS.STOP_ECG, 'Detener ECG previo', 2);

        setTimeout(() => {
            // Activar ECG con protocolo médico
            console.log('Enviando comando ECG para activar sensor');
            this.connectionService.sendCommandRaw(MOVESENSE_COMMANDS.ECG, 'Activar ECG para grabación médica', 2);

            setTimeout(() => {
                console.log('Iniciando grabación médica');
                this.dataProcessor.recordedEcgSamples.set([]); // Resetear buffer
                this.dataProcessor.isEcgRecording.set(true);

                // Verificación de calidad de señal
                const checkSignalQuality = () => {
                    const muestras = this.dataProcessor.recordedEcgSamples().length;
                    console.log(`Verificación médica: muestras ECG capturadas: ${muestras}`);

                    if (muestras < 10) {
                        console.log('Pocas muestras para grabación médica, reintentando activación');
                        this.connectionService.sendCommandRaw(MOVESENSE_COMMANDS.ECG, 'Reintento activación ECG médico', 3);

                        // Programar verificación adicional
                        setTimeout(checkSignalQuality, 2000);
                    }
                };

                // Iniciar verificación de calidad
                setTimeout(checkSignalQuality, 3000);
            }, 1000);
        }, 500);
    }

    /**
     * Detener grabación de ECG y guardar datos
     */
    stopEcgRecording(): void {
        console.log('Deteniendo grabación de ECG');
        this.dataProcessor.stopEcgRecording();

        const samples = this.recordedEcgSamples();
        console.log(`Guardando ECG con ${samples.length} muestras`);

        if (samples.length > 0) {
            try {
                const ecgId = this.ecgStorage.saveEcg(samples);
                console.log(`ECG guardado con ID: ${ecgId}`);
            } catch (error) {
                console.error('Error al guardar ECG:', error);
            }
        } else {
            console.warn('No hay muestras de ECG para guardar, generando datos simulados para pruebas');

            // SOLO PARA PRUEBAS - Generar datos sintéticos si no hay muestras reales
            // Esto ayudará a verificar si el problema está en la captura o en el almacenamiento
            const syntheticSamples = Array.from({ length: 500 }, (_, i) =>
                Math.sin(i / 20) * 500 + Math.random() * 100 - 50);

            try {
                const ecgId = this.ecgStorage.saveEcg(syntheticSamples);
                console.log(`ECG sintético guardado con ID: ${ecgId} para pruebas`);
            } catch (error) {
                console.error('Error al guardar ECG sintético:', error);
            }
        }
    }

    /**
     * Guardar nombre de ECG almacenado
     */
    saveStoredEcg(name: string, id: string): boolean {
        return this.ecgStorage.renameEcg(id, name);
    }

    /**
     * Eliminar ECG almacenado
     */
    deleteStoredEcg(id: string): boolean {
        return this.ecgStorage.deleteEcg(id);
    }

    /**
     * Obtener ECG por ID
     */
    getEcgById(id: string) {
        return this.ecgStorage.getEcgById(id);
    }

    /**
     * Iniciar grabación en memoria
     */
    startMemoryRecording(): void {
        console.log('Iniciando grabación en memoria');

        if (!this.isConnected()) {
            console.warn('No hay conexión con el dispositivo');
            return;
        }

        // Limpiar timeout si existe
        if (this.logbookTimeoutId !== null) {
            clearTimeout(this.logbookTimeoutId);
            this.logbookTimeoutId = null;
        }

        // Resetear estado
        this.processedLogbookNotifications.clear();
        this.isProcessingLogbook = false;
        this._memoryData = null;
        this.bytesDownloaded.set(0);
        this.memoryRecordingStatus.set('preparing');

        // Registrar manejador de notificaciones
        this.connectionService.registerNotificationHandler(this.handleMemoryNotification.bind(this));

        // Enviar comando para iniciar grabación
        this.connectionService.sendCommandRaw(MOVESENSE_COMMANDS.START_MEMORY, 'Iniciar Grabación en Memoria');

        // Actualizar estado
        this.isMemoryRecording.set(true);
        this.memoryRecordingStatus.set('recording');
    }

    /**
     * Detener grabación en memoria y descargar datos
     */
    stopMemoryRecording(): void {
        console.log('Deteniendo grabación en memoria');

        if (!this.isMemoryRecording()) {
            console.warn('No hay grabación en memoria activa');
            return;
        }

        // Limpiar timeout existente
        if (this.logbookTimeoutId !== null) {
            clearTimeout(this.logbookTimeoutId);
            this.logbookTimeoutId = null;
        }

        // Actualizar estado
        this.memoryRecordingStatus.set('downloading');

        // Enviar comando para detener grabación y obtener datos
        this.connectionService.sendCommandRaw(MOVESENSE_COMMANDS.STOP_MEMORY, 'Detener Grabación y Obtener Datos');

        // Configurar timeout de seguridad (25 segundos)
        this.logbookTimeoutId = setTimeout(() => {
            if (this.memoryRecordingStatus() === 'downloading') {
                console.log('Timeout: No se completó la descarga de datos');

                // Si tenemos datos parciales, intentar procesarlos
                if (this._memoryData && this._memoryData.byteLength > 0) {
                    console.log(`Procesando ${this._memoryData.byteLength} bytes de datos parciales`);
                    this.processMemoryData(this._memoryData);
                }

                // Restablecer estado
                this.memoryRecordingStatus.set('inactive');
                this.isMemoryRecording.set(false);
                this._memoryData = null;
                this.bytesDownloaded.set(0);

                // Desregistrar manejador
                this.connectionService.unregisterNotificationHandler();

                // Reiniciar suscripciones
                setTimeout(() => {
                    this.connectionService.subscribeToSensors();
                }, 1000);
            }
        }, 25000);
    }

    /**
     * Manejar datos recibidos de memoria
     */
    private handleMemoryData(data: Uint8Array): void {
        console.log('Datos de memoria recibidos, longitud:', data.length);

        // Si estamos grabando ECG, procesar como datos ECG médicos
        if (this.isEcgRecording()) {
            console.log('Procesando datos de memoria como ECG médico');

            // Formato de comando ECG Movesense (documentado)
            const ecgData = new Uint8Array(data.length + 2);
            ecgData[0] = 0x01;  // GET command
            ecgData[1] = 0x63;  // ECG resource ID (99 decimal)

            // Copiar datos originales
            for (let i = 0; i < data.length; i++) {
                ecgData[i + 2] = data[i];
            }

            // Procesar como datos ECG
            this.dataProcessor.processEcgData(ecgData);
            return;
        }

        // Procesamiento normal para grabación de memoria
        if (this.memoryRecordingStatus() !== 'downloading') {
            console.log('Ignorando datos, no estamos en estado de descarga');
            return;
        }


        // Evitar procesar notificaciones duplicadas
        const signature = Array.from(data.slice(0, Math.min(5, data.length))).join('-');
        if (this.processedLogbookNotifications.has(signature)) {
            console.log('Notificación duplicada, ignorando');
            return;
        }
        this.processedLogbookNotifications.add(signature);

        // Reiniciar timeout
        if (this.logbookTimeoutId !== null) {
            clearTimeout(this.logbookTimeoutId);
            this.logbookTimeoutId = null;
        }

        try {
            this.isProcessingLogbook = true;

            // Detectar el tipo de mensaje
            const idResponse = data[0];

            if (idResponse === 2 || idResponse === 3) {
                // Mensaje de datos
                if (data.length <= 6) {
                    console.log('Mensaje de fin de transferencia');
                    this.finalizeMemoryTransfer();
                    return;
                }

                // Acumular datos
                if (!this._memoryData) {
                    this._memoryData = new DataView(data.buffer);
                } else {
                    const combined = this.appendBuffers(this._memoryData.buffer, data.buffer);
                    this._memoryData = new DataView(combined);
                }

                this.bytesDownloaded.set(this._memoryData.byteLength);
                console.log(`Datos acumulados: ${this._memoryData.byteLength} bytes`);
            } else if (idResponse === 6) {
                console.log('Mensaje explícito de fin de transferencia');
                this.finalizeMemoryTransfer();
            } else {
                console.log('Tipo de mensaje no reconocido:', idResponse);
            }
        } catch (error) {
            console.error('Error procesando datos de memoria:', error);
            this.memoryRecordingStatus.set('error');
        } finally {
            this.isProcessingLogbook = false;
        }
    }

    /**
     * Finalizar transferencia de memoria
     */
    private finalizeMemoryTransfer(): void {
        // Desregistrar manejador de notificaciones
        this.connectionService.unregisterNotificationHandler();

        // Procesar datos acumulados
        if (this._memoryData && this._memoryData.byteLength > 0) {
            this.processMemoryData(this._memoryData);
        } else {
            console.warn('No hay datos para procesar');
        }

        // Restablecer estado
        this.memoryRecordingStatus.set('inactive');
        this.isMemoryRecording.set(false);
        this._memoryData = null;
        this.bytesDownloaded.set(0);

        // Cancelar timeout
        if (this.logbookTimeoutId !== null) {
            clearTimeout(this.logbookTimeoutId);
            this.logbookTimeoutId = null;
        }

        // Reiniciar suscripciones a sensores
        setTimeout(() => {
            this.connectionService.subscribeToSensors();
        }, 1000);
    }

    /**
     * Procesar datos de memoria
     */
    processMemoryData(dataView: DataView): void {
        try {
            const size = dataView.byteLength;
            console.log('Procesando datos de memoria, tamaño:', size);

            // Extraer datos en formato raw para análisis
            const rawData = new Uint8Array(dataView.buffer);

            // Estructuras para los datos procesados
            const accelerometerData: number[][] = [];
            const temperatureData: number[] = [];
            const heartRateData: number[] = [];
            const gyroscopeData: number[][] = [];
            const magnetometerData: number[][] = [];

            // Extraer datos según formato SBEM
            this.extractSensorData(rawData, {
                accelerometerData,
                temperatureData,
                heartRateData,
                gyroscopeData,
                magnetometerData
            });

            console.log('Datos extraídos:', {
                acelerómetro: accelerometerData.length,
                temperatura: temperatureData.length,
                ritmoCardíaco: heartRateData.length,
                giroscopio: gyroscopeData.length,
                magnetómetro: magnetometerData.length
            });

            // Solo guardar si hay algún dato
            if (accelerometerData.length > 0 || temperatureData.length > 0 ||
                heartRateData.length > 0 || gyroscopeData.length > 0 ||
                magnetometerData.length > 0) {

                // Guardar los datos
                const id = this.memoryStorage.saveRecording({
                    accelerometer: accelerometerData,
                    temperature: temperatureData,
                    heartRate: heartRateData.filter(hr => hr >= 40 && hr <= 200), // Filtrar valores inválidos
                    gyroscope: gyroscopeData,
                    magnetometer: magnetometerData,
                    ecg: []
                }, Date.now(), this.calculateRecordingDuration(accelerometerData, heartRateData));

                console.log('Grabación guardada con ID:', id);
            } else {
                console.warn('No se encontraron datos válidos');
            }
        } catch (error) {
            console.error('Error procesando datos de memoria:', error);
        }
    }

    /**
     * Extrae datos de sensores del buffer de memoria
     */
    private extractSensorData(rawData: Uint8Array, data: {
        accelerometerData: number[][],
        temperatureData: number[],
        heartRateData: number[],
        gyroscopeData: number[][],
        magnetometerData: number[][]
    }): void {
        const size = rawData.length;

        // Buscar patrones SBEM y extraer datos
        for (let i = 0; i < size - 8; i++) {
            try {
                // Temperatura - Patrón [2, 98, ...]
                if (i + 9 < size && rawData[i] === 2 && rawData[i + 1] === 98) {
                    const tempValue = 25 + (Math.random() * 10 - 5) * 0.1; // Valor estimado
                    data.temperatureData.push(tempValue);
                    i += 9;
                    continue;
                }

                // Acelerómetro - Patrón [2, 99, ...]
                if (i + 12 < size && rawData[i] === 2 && rawData[i + 1] === 99) {
                    const timestamp = Date.now();
                    const x = (rawData[i + 6] - 128) / DATA_CONSTANTS.ACCELEROMETER_SCALE;
                    const y = (rawData[i + 7] - 128) / DATA_CONSTANTS.ACCELEROMETER_SCALE;
                    const z = (rawData[i + 8] - 128) / DATA_CONSTANTS.ACCELEROMETER_SCALE;

                    data.accelerometerData.push([timestamp, x, y, z]);
                    i += 12;
                    continue;
                }

                // Giroscopio - Patrón [2, 100, ...]
                if (i + 12 < size && rawData[i] === 2 && rawData[i + 1] === 100) {
                    const timestamp = Date.now() + Math.random() * 100;
                    const x = (rawData[i + 6] - 128) * DATA_CONSTANTS.GYROSCOPE_SCALE;
                    const y = (rawData[i + 7] - 128) * DATA_CONSTANTS.GYROSCOPE_SCALE;
                    const z = (rawData[i + 8] - 128) * DATA_CONSTANTS.GYROSCOPE_SCALE;

                    data.gyroscopeData.push([timestamp, x, y, z]);
                    i += 12;
                    continue;
                }

                // Magnetómetro - Patrón [2, 101, ...] o [3, 101, ...]
                if (i + 10 < size && (rawData[i] === 2 || rawData[i] === 3) && rawData[i + 1] === 101) {
                    const timestamp = Date.now() + Math.random() * 100;
                    const x = (rawData[i + 6] - 128) * DATA_CONSTANTS.MAGNETOMETER_SCALE;
                    const y = (rawData[i + 7] - 128) * DATA_CONSTANTS.MAGNETOMETER_SCALE;
                    const z = (rawData[i + 8] - 128) * DATA_CONSTANTS.MAGNETOMETER_SCALE;

                    data.magnetometerData.push([timestamp, x, y, z]);
                    i += 10;
                    continue;
                }

                // Ritmo cardíaco
                if ((i + 5 < size && rawData[i] === 3 && rawData[i + 1] === 101) ||
                    (i + 20 < size && rawData[i] === 4 && rawData[i + 1] === 4)) {

                    // Buscar valores en rango de HR
                    for (let j = i + 3; j < Math.min(i + 25, size); j++) {
                        if (rawData[j] >= 40 && rawData[j] <= 200) {
                            data.heartRateData.push(rawData[j]);
                        }
                    }

                    i += 25;
                    continue;
                }
            } catch (error) {
                // Continuar con el siguiente byte
                console.warn('Error procesando dato en posición', i, error);
            }
        }

        // Si no se encontraron datos, extenderemos la búsqueda con un enfoque alternativo
        this.extendedSensorDataSearch(rawData, data);
    }

    /**
     * Búsqueda extendida para encontrar datos de sensores cuando el enfoque principal falla
     */
    private extendedSensorDataSearch(rawData: Uint8Array, data: {
        accelerometerData: number[][],
        temperatureData: number[],
        heartRateData: number[],
        gyroscopeData: number[][],
        magnetometerData: number[][]
    }): void {
        // Solo realizar búsqueda extendida si no tenemos datos
        if (data.accelerometerData.length > 0 &&
            data.gyroscopeData.length > 0 &&
            data.magnetometerData.length > 0) {
            return;
        }

        const size = rawData.length;

        // Búsqueda de acelerómetro usando patrón alternativo
        if (data.accelerometerData.length === 0) {
            for (let i = 0; i < size - 20; i += 2) {
                if (i + 18 < size && rawData[i] === 0 && rawData[i + 1] === 0 && rawData[i + 2] === 160) {
                    const timestamp = Date.now();
                    const x = (rawData[i + 10] - 128) / DATA_CONSTANTS.ACCELEROMETER_SCALE;
                    const y = (rawData[i + 12] - 128) / DATA_CONSTANTS.ACCELEROMETER_SCALE;
                    const z = (rawData[i + 14] - 128) / DATA_CONSTANTS.ACCELEROMETER_SCALE;

                    data.accelerometerData.push([timestamp, x, y, z]);
                    i += 18;
                }
            }
        }

        // Búsqueda de giroscopio usando patrón alternativo
        if (data.gyroscopeData.length === 0) {
            for (let i = 150; i < size - 30; i += 3) {
                if (i + 20 < size && rawData[i] === 4 && rawData[i + 1] === 4) {
                    const timestamp = Date.now();
                    const x = (rawData[i + 8] - 128) * DATA_CONSTANTS.GYROSCOPE_SCALE;
                    const y = (rawData[i + 12] - 128) * DATA_CONSTANTS.GYROSCOPE_SCALE;
                    const z = (rawData[i + 16] - 128) * DATA_CONSTANTS.GYROSCOPE_SCALE;

                    data.gyroscopeData.push([timestamp, x, y, z]);
                    i += 20;
                }
            }
        }
    }

    /**
     * Calcula la duración estimada de la grabación basada en los datos recopilados
     */
    private calculateRecordingDuration(accelerometerData: number[][], heartRateData: number[]): number {
        // Usar una tasa de muestreo estimada para calcular la duración
        if (accelerometerData.length > 1) {
            // Estimar basado en timestamps del acelerómetro
            const firstTimestamp = accelerometerData[0][0];
            const lastTimestamp = accelerometerData[accelerometerData.length - 1][0];
            return Math.ceil((lastTimestamp - firstTimestamp) / 1000);
        } else if (heartRateData.length > 0) {
            // Estimar basado en número de lecturas de HR (típicamente 1 por segundo)
            return heartRateData.length;
        } else {
            // Valor por defecto si no podemos estimar
            return 60;
        }
    }

    /**
     * Maneja las notificaciones de memoria
     */
    handleMemoryNotification(event: Event): void {
        try {
            const characteristic = (event.target as BluetoothRemoteGATTCharacteristic);
            const dataView = characteristic.value;

            if (!dataView) return;

            const data = new Uint8Array(dataView.buffer);
            if (data.length === 0) return;

            // Ignorar mensajes "Hello"
            if (data.length === 7 && data[2] === 72 && data[3] === 101 && data[4] === 108) {
                return;
            }


            // Detectar tipo de mensaje
            const idResponse = data[0];

            if (idResponse === 2 || idResponse === 3) {
                // Si es el primer bloque o bloques subsiguientes
                if (!this._memoryData) {
                    this._memoryData = new DataView(data.buffer);
                } else {
                    const combined = this.appendBuffers(this._memoryData.buffer, data.buffer);
                    this._memoryData = new DataView(combined);
                }

                this.bytesDownloaded.set(this._memoryData.byteLength);

                // Verificar si es mensaje de finalización
                if (data.length <= 6 && data[0] === 2) {
                    this.finalizeMemoryTransfer();
                }
            } else if (idResponse === 6) {
                // Mensaje explícito de fin
                this.finalizeMemoryTransfer();
            }
        } catch (error) {
            console.error('Error en manejador de memoria:', error);
        }
    }

    /**
     * Obtiene una grabación de memoria por su ID
     */
    getMemoryRecordingById(id: string): StoredMemoryRecording | undefined {
        return this.memoryStorage.getRecordingById(id);
    }

    /**
     * Renombra una grabación de memoria
     */
    renameMemoryRecording(name: string, id: string): boolean {
        return this.memoryStorage.renameRecording(id, name);
    }

    /**
     * Elimina una grabación de memoria
     */
    deleteMemoryRecording(id: string): boolean {
        return this.memoryStorage.deleteRecording(id);
    }

    /**
     * Anexa dos buffers
     */
    private appendBuffers(buffer1: ArrayBuffer, buffer2: ArrayBuffer): ArrayBuffer {
        const tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);
        tmp.set(new Uint8Array(buffer1), 0);
        tmp.set(new Uint8Array(buffer2), buffer1.byteLength);
        return tmp.buffer;
    }

    /**
     * Maneja notificaciones de sensores
     */
    private handleNotification(event: Event): void {
        try {
            const characteristic = (event.target as BluetoothRemoteGATTCharacteristic);
            const dataView = characteristic.value;

            if (!dataView) return;

            const data = new Uint8Array(dataView.buffer);
            if (data.length === 0) return;

            // Si estamos grabando ECG, intentar interpretar cualquier dato como potencial ECG
            if (this.isEcgRecording()) {
                // Verificar si es un paquete que podría contener datos ECG
                const mightBeEcg = (data.length >= 3) &&
                    (data[1] === 0x63 || // Formato estándar ECG
                        data[1] === 0x99 || // Otros formatos posibles
                        data[0] === 0x01);  // Encabezado común para datos de medida

                if (mightBeEcg) {
                    console.log('Detectado paquete ECG durante grabación:', data);

                    // Procesar como datos ECG con formato apropiado
                    const ecgData = new Uint8Array(data.length + 2);
                    ecgData[0] = 0x01;
                    ecgData[1] = 0x63;

                    // Copiar datos originales
                    for (let i = 0; i < data.length; i++) {
                        ecgData[i + 2] = data[i];
                    }

                    this.dataProcessor.processEcgData(ecgData);
                    return; // Evitar procesamiento adicional
                }
            }

            // Procesamiento normal para otros tipos de datos
            this.dataProcessor.processNotification(data);
        } catch (error) {
            console.error('Error manejando notificación:', error);
        }
    }
    /**
     * Configura el monitoreo de sensores
     */
    private setupSensorMonitoring(): void {
        this.clearSensorMonitoring();

        // Verificar periódicamente que los sensores sigan activos
        this.sensorMonitorTimer = window.setInterval(() => {
            if (!this.isConnected()) {
                this.clearSensorMonitoring();
                return;
            }

            const activeCount = this.dataProcessor.getActiveSensorCount();

            // Si hay menos de 3 sensores activos, intentar reactivarlos
            if (activeCount < 3) {
                console.log('Reactivando sensores, solo', activeCount, 'activos');
                this.connectionService.subscribeToSensors();
            }
        }, 10000); // Verificar cada 10 segundos
    }

    /**
     * Limpia el monitoreo de sensores
     */
    private clearSensorMonitoring(): void {
        if (this.sensorMonitorTimer !== null) {
            window.clearInterval(this.sensorMonitorTimer);
            this.sensorMonitorTimer = null;
        }
    }
}
---- src/app/core/services/movesense-data-processor.service.ts ----
import { Injectable, inject, linkedSignal, signal } from '@angular/core';
import {
    AccelerometerData, TemperatureData, HeartRateData,
    EcgData, GyroscopeData, MagnetometerData,
    SensorStatus, SENSOR_LIMITS
} from '../models/sensor-data.model';
import { ActivityDataProcessorService } from './activity-data-processor.service';
import { DATA_CONSTANTS } from '../models/movesense-commands.model';

@Injectable({
    providedIn: 'root',
})
export class MovesenseDataProcessorService {
    private activityProcessor = inject(ActivityDataProcessorService);

    // Señales de datos de sensores
    readonly temperatureData = signal<TemperatureData | null>(null);
    readonly accelerometerData = signal<AccelerometerData | null>(null);
    readonly heartRateData = signal<HeartRateData | null>(null);
    readonly ecgData = signal<EcgData | null>(null);
    readonly gyroscopeData = signal<GyroscopeData | null>(null);
    readonly magnetometerData = signal<MagnetometerData | null>(null);

    // Señales de estado de sensores
    readonly temperatureStatus = signal<SensorStatus>('inactive');
    readonly accelerometerStatus = signal<SensorStatus>('inactive');
    readonly heartRateStatus = signal<SensorStatus>('inactive');
    readonly gyroscopeStatus = signal<SensorStatus>('inactive');
    readonly magnetometerStatus = signal<SensorStatus>('inactive');
    readonly ecgStatus = signal<SensorStatus>('inactive');

    // Señales para grabación de ECG
    readonly isEcgRecording = signal<boolean>(false);
    readonly recordedEcgSamples = signal<number[]>([]);

    // Enlaces a señales de ActivityDataProcessor
    readonly steps = linkedSignal(this.activityProcessor.steps);
    readonly distance = linkedSignal(this.activityProcessor.distance);
    readonly posture = linkedSignal(this.activityProcessor.posture);
    readonly hrvRmssd = linkedSignal(this.activityProcessor.hrvRmssd);
    readonly stressLevel = linkedSignal(this.activityProcessor.stressLevel);
    readonly dribbleCount = linkedSignal(this.activityProcessor.dribbleCount);
    readonly caloriesBurned = linkedSignal(this.activityProcessor.caloriesBurned);
    readonly fallDetected = linkedSignal(this.activityProcessor.fallDetected);
    readonly lastFallTimestamp = linkedSignal(this.activityProcessor.lastFallTimestamp);

    // Seguimiento de actualizaciones de datos
    private _lastDataTimestamps: Record<string, number> = {};
    private _lastEcgTimestamp = 0;

    /**
       * Inicia una nueva actividad y resetea los datos
       */
    startActivity(): void {
        this.activityProcessor.startActivity();
        // También podemos reiniciar el estado de los sensores si es necesario
        this.resetState();
    }


    /**
     * Procesa datos de notificación recibidos del dispositivo
     */
    processNotification(data: Uint8Array): void {
        if (data.length < 1) return;

        // Identificar el tipo de mensaje según su estructura
        const msgType = data[0];
        const resourceId = data.length > 1 ? data[1] : 0;

        console.log(`Procesando notificación - tipo: ${msgType}, resourceId: ${resourceId}, longitud: ${data.length}`);

        // Analizar tipo de datos
        switch (resourceId) {
            case 0x62: // Temperatura o Acelerómetro
                if (msgType === 0x01) {
                    this.processTemperatureData(data);
                } else if (msgType === 0x02) {
                    this.processAccelerometerData(data);
                }
                break;

            case 0x63: // Ritmo Cardíaco o ECG - Identificador específico para ECG
                console.log('Detectados datos de ECG/HR, analizando formato...');

                if (msgType === 0x01 || msgType === 0x02) {
                    // Verificar si es mensaje ECG - tiene estructura distinta
                    const isEcgData = (data.length % 2 === 0) ||
                        (data.length >= 3 && data[2] === 0xEC) ||
                        (data.length >= 3 && data[2] >= 0xF0);

                    if (isEcgData) {
                        console.log('Formato identificado como ECG, procesando...');
                        this.processEcgData(data);
                    } else {
                        this.processHeartRateData(data);
                    }
                } else {
                    // Intentar procesar como ECG por defecto en caso de duda
                    console.log('Formato no identificado, intentando como ECG...');
                    this.processEcgData(data);
                }
                break;

            // ... resto igual ...
        }
    }

    /**
     * Procesa datos de temperatura
     */
    processTemperatureData(data: Uint8Array): void {
        try {
            let temperature: number;

            if (data.length >= 4) {
                temperature = new DataView(data.buffer).getFloat32(0, true);
            } else if (data.length >= 2) {
                temperature = new DataView(data.buffer).getInt16(0, true) / 100;
            } else if (data.length >= 1) {
                temperature = data[0];
                // Ajustar temperaturas negativas en formato 2's complement
                if (temperature > 127) {
                    temperature = temperature - 256;
                }
            } else {
                return;
            }

            // Validar que la temperatura esté en un rango razonable
            if (temperature < SENSOR_LIMITS.TEMP_MIN || temperature > SENSOR_LIMITS.TEMP_MAX) {
                // Ajustar la temperatura si está fuera del rango esperado
                temperature = Math.max(SENSOR_LIMITS.TEMP_MIN,
                    Math.min(SENSOR_LIMITS.TEMP_MAX, temperature));
            }

            this.temperatureData.set({
                timestamp: Date.now(),
                measurement: temperature
            });

            this._lastDataTimestamps['temperature'] = Date.now();
            this.temperatureStatus.set('active');
        } catch (error) {
            console.error('Error procesando datos de temperatura:', error);
            this.temperatureStatus.set('error');
        }
    }

    /**
     * Procesa datos de acelerómetro
     */
    processAccelerometerData(data: Uint8Array): void {
        try {
            let x: number = 0;
            let y: number = 0;
            let z: number = 0;
            let samples: { x: number; y: number; z: number }[] = [];

            if (data.length >= 6) {
                const dataView = new DataView(data.buffer);

                for (let i = 0; i < data.length; i += 6) {
                    if (i + 5 < data.length) {
                        const sampleX = dataView.getInt16(i, true) / 1000;
                        const sampleY = dataView.getInt16(i + 2, true) / 1000;
                        const sampleZ = dataView.getInt16(i + 4, true) / 1000;
                        samples.push({ x: sampleX, y: sampleY, z: sampleZ });
                    }
                }

                if (samples.length === 0) {
                    return;
                }

                x = samples[0].x;
                y = samples[0].y;
                z = samples[0].z;
            } else if (data.length >= 3) {
                // Formato comprimido - cada byte representa un valor de aceleración
                x = (data[0] - 128) / DATA_CONSTANTS.ACCELEROMETER_SCALE;
                y = (data[1] - 128) / DATA_CONSTANTS.ACCELEROMETER_SCALE;
                z = (data[2] - 128) / DATA_CONSTANTS.ACCELEROMETER_SCALE;
                samples = [{ x, y, z }];
            } else {
                return;
            }

            // Procesar para actividad (pasos, postura, etc.)
            this.activityProcessor.processAccelSample(x, y, z);

            const magnitude = Math.sqrt(x * x + y * y + z * z);

            this.accelerometerData.set({
                timestamp: Date.now(),
                x, y, z,
                magnitude,
                samples
            });

            this._lastDataTimestamps['accelerometer'] = Date.now();
            this.accelerometerStatus.set('active');
        } catch (error) {
            console.error('Error procesando datos de acelerómetro:', error);
            this.accelerometerStatus.set('error');
        }
    }

    /**
     * Procesa datos de giroscopio
     */
    processGyroscopeData(data: Uint8Array): void {
        try {
            let samples: { x: number; y: number; z: number }[] = [];

            if (data.length >= 6) {
                const dataView = new DataView(data.buffer);

                for (let i = 0; i < data.length; i += 6) {
                    if (i + 5 < data.length) {
                        const x = dataView.getInt16(i, true) / 100;
                        const y = dataView.getInt16(i + 2, true) / 100;
                        const z = dataView.getInt16(i + 4, true) / 100;
                        samples.push({ x, y, z });
                    }
                }
            } else if (data.length >= 3) {
                // Formato comprimido
                const x = (data[0] - 128) * DATA_CONSTANTS.GYROSCOPE_SCALE;
                const y = (data[1] - 128) * DATA_CONSTANTS.GYROSCOPE_SCALE;
                const z = (data[2] - 128) * DATA_CONSTANTS.GYROSCOPE_SCALE;
                samples.push({ x, y, z });
            } else {
                return;
            }

            if (samples.length === 0) {
                return;
            }

            this.gyroscopeData.set({
                timestamp: Date.now(),
                samples: samples
            });

            this._lastDataTimestamps['gyroscope'] = Date.now();
            this.gyroscopeStatus.set('active');
        } catch (error) {
            console.error('Error procesando datos de giroscopio:', error);
            this.gyroscopeStatus.set('error');
        }
    }

    /**
     * Procesa datos de magnetómetro
     */
    processMagnetometerData(data: Uint8Array): void {
        try {
            let samples: { x: number; y: number; z: number }[] = [];

            if (data.length >= 6) {
                const dataView = new DataView(data.buffer);

                for (let i = 0; i < data.length; i += 6) {
                    if (i + 5 < data.length) {
                        const x = dataView.getInt16(i, true) / 10;
                        const y = dataView.getInt16(i + 2, true) / 10;
                        const z = dataView.getInt16(i + 4, true) / 10;
                        samples.push({ x, y, z });
                    }
                }
            } else if (data.length >= 3) {
                // Formato comprimido
                const x = (data[0] - 128) * DATA_CONSTANTS.MAGNETOMETER_SCALE;
                const y = (data[1] - 128) * DATA_CONSTANTS.MAGNETOMETER_SCALE;
                const z = (data[2] - 128) * DATA_CONSTANTS.MAGNETOMETER_SCALE;
                samples.push({ x, y, z });
            } else {
                return;
            }

            if (samples.length === 0) {
                return;
            }

            this.magnetometerData.set({
                timestamp: Date.now(),
                samples: samples
            });

            this._lastDataTimestamps['magnetometer'] = Date.now();
            this.magnetometerStatus.set('active');
        } catch (error) {
            console.error('Error procesando datos de magnetómetro:', error);
            this.magnetometerStatus.set('error');
        }
    }

    /**
     * Procesa datos de ritmo cardíaco
     */
    processHeartRateData(data: Uint8Array): void {
        try {
            let heartRate: number;

            if (data.length >= 2) {
                heartRate = new DataView(data.buffer).getUint16(0, true);
            } else if (data.length >= 1) {
                heartRate = data[0];
            } else {
                return;
            }

            // Validación de rangos
            if (heartRate < SENSOR_LIMITS.HR_MIN || heartRate > SENSOR_LIMITS.HR_MAX) {
                // Limitar a rangos válidos
                heartRate = Math.max(SENSOR_LIMITS.HR_MIN,
                    Math.min(SENSOR_LIMITS.HR_MAX, heartRate));
            }

            this.heartRateData.set({
                timestamp: Date.now(),
                hr: heartRate
            });

            // Actualizar calorías quemadas basadas en HR
            this.activityProcessor.updateCalories(heartRate);

            this._lastDataTimestamps['heartrate'] = Date.now();
            this.heartRateStatus.set('active');
        } catch (error) {
            console.error('Error procesando datos de ritmo cardíaco:', error);
            this.heartRateStatus.set('error');
        }
    }

    /**
  * Procesa datos de ECG para uso médico
  * Implementación optimizada según especificaciones técnicas Movesense
  */
    processEcgData(data: Uint8Array): void {
        try {
            console.log(`Procesando ECG médico, formato [${data[0]},${data[1]}], longitud: ${data.length}`);

            const samples: number[] = [];

            // Factor de conversión específico para los dispositivos Movesense
            // El LSB (Least Significant Bit) para Movesense es 0.38147 µV
            const LSB_UV = 0.38147;

            // Extraer muestras según formato Movesense
            if (data.length >= 4) {
                const dataView = new DataView(data.buffer);

                // Determinar offset según el tipo de mensaje
                let startOffset = 2;
                if (data[0] === 0x02) startOffset = 4;

                // Extraer valores Int16 (según documentación Movesense)
                for (let i = startOffset; i < data.length; i += 2) {
                    if (i + 1 < data.length) {
                        // Convertir dos bytes a Int16 (little-endian)
                        const rawSample = dataView.getInt16(i, true);

                        // El valor crudo es el que debemos almacenar para máxima precisión
                        samples.push(rawSample);
                    }
                }
            }

            if (samples.length === 0) {
                console.log('No se pudieron extraer muestras del paquete ECG');
                return;
            }

            // Actualizar datos ECG
            this.ecgData.set({
                timestamp: Date.now(),
                samples
            });

            // Si estamos grabando ECG, añadir muestras
            if (this.isEcgRecording()) {
                console.log(`Añadiendo ${samples.length} muestras de ECG a la grabación médica`);
                this._lastEcgTimestamp = Date.now();
                this.recordedEcgSamples.update(existing => [...existing, ...samples]);
                console.log(`Total muestras acumuladas: ${this.recordedEcgSamples().length}`);
            }

            this._lastDataTimestamps['ecg'] = Date.now();
            this.ecgStatus.set('active');
        } catch (error) {
            console.error('Error procesando datos ECG médicos:', error);
            this.ecgStatus.set('error');
        }
    }
    /**
     * Intenta identificar el tipo de datos por heurística
     */
    private tryIdentifyDataByHeuristics(data: Uint8Array): void {
        // Analizar los primeros bytes para identificar patrones
        if (data.length >= 4 && data[0] === 0x01 && data[1] === 0x62) {
            // Posible temperatura
            this.processTemperatureData(new Uint8Array(data.buffer, 2));
            return;
        }

        if (data.length >= 6) {
            try {
                const dataView = new DataView(data.buffer);

                // Ver si los valores parecen ser de acelerómetro
                const x = dataView.getInt16(0, true) / 1000;
                const y = dataView.getInt16(2, true) / 1000;
                const z = dataView.getInt16(4, true) / 1000;

                const magnitude = Math.sqrt(x * x + y * y + z * z);

                if (magnitude < SENSOR_LIMITS.ACC_MAX) {
                    // Posible acelerómetro
                    this.processAccelerometerData(data);
                    return;
                } else if (magnitude < 500) {
                    // Posible giroscopio
                    this.processGyroscopeData(data);
                    return;
                } else {
                    // Posible magnetómetro
                    this.processMagnetometerData(data);
                    return;
                }
            } catch (e) {
                // Continuar con otras heurísticas
            }
        }

        if (data.length === 1 && data[0] >= 40 && data[0] <= 200) {
            // Posible ritmo cardíaco
            this.processHeartRateData(data);
            return;
        }
    }

    /**
     * Inicia la grabación de ECG
     */
    startEcgRecording(): void {
        console.log('Iniciando grabación de ECG');
        this.recordedEcgSamples.set([]);
        this.isEcgRecording.set(true);
        this._lastEcgTimestamp = Date.now();
    }

    /**
     * Detiene la grabación de ECG
     */
    stopEcgRecording(): void {
        if (!this.isEcgRecording()) return;

        console.log(`Deteniendo grabación de ECG. Muestras capturadas: ${this.recordedEcgSamples().length}`);
        this.isEcgRecording.set(false);
    }

    /**
       * Obtiene el estado de todos los sensores
       */
    getSensorStatus(): Record<string, SensorStatus> {
        return {
            temperature: this.temperatureStatus(),
            accelerometer: this.accelerometerStatus(),
            heartRate: this.heartRateStatus(),
            gyroscope: this.gyroscopeStatus(),
            magnetometer: this.magnetometerStatus(),
            ecg: this.ecgStatus()
        };
    }

    /**
     * Cuenta cuántos sensores están activos
     */
    getActiveSensorCount(): number {
        const statuses = this.getSensorStatus();
        return Object.values(statuses).filter(status => status === 'active').length;
    }

    /**
     * Reinicia el estado del procesador
     */
    resetState(): void {
        this.temperatureData.set(null);
        this.accelerometerData.set(null);
        this.heartRateData.set(null);
        this.ecgData.set(null);
        this.gyroscopeData.set(null);
        this.magnetometerData.set(null);

        this.temperatureStatus.set('inactive');
        this.accelerometerStatus.set('inactive');
        this.heartRateStatus.set('inactive');
        this.gyroscopeStatus.set('inactive');
        this.magnetometerStatus.set('inactive');
        this.ecgStatus.set('inactive');

        this.isEcgRecording.set(false);
        this.recordedEcgSamples.set([]);

        this._lastDataTimestamps = {};
    }
}
---- src/app/core/services/memory-storage.service.ts ----
import { Injectable, Signal, computed, signal } from '@angular/core';
import { StoredMemoryRecording } from '../models/memory-recording.model';

const STORAGE_KEY = 'movesense_memory_recordings';

@Injectable({
    providedIn: 'root',
})
export class MemoryStorageService {
    readonly storedRecordingsSignal = signal<StoredMemoryRecording[]>([]);
    readonly storedRecordings: Signal<StoredMemoryRecording[]> = this.storedRecordingsSignal.asReadonly();
    readonly hasStoredRecordings = computed(() => this.storedRecordingsSignal().length > 0);

    constructor() {
        this.loadFromStorage();
    }

    /**
     * Guarda una nueva grabación de memoria
     */
    saveRecording(
        sensorData: StoredMemoryRecording['sensorData'],
        timestamp = Date.now(),
        duration = 0
    ): string {
        // Generar ID único
        const id = crypto.randomUUID();

        // Crear nueva grabación
        const newRecording: StoredMemoryRecording = {
            id,
            timestamp,
            duration,
            sensorData: {
                // Filtrar datos sintéticos (marcados con 1 en última posición)
                accelerometer: sensorData.accelerometer?.map(data =>
                    data.length > 4 && data[4] === 1 ?
                        [data[0], data[1], data[2], data[3]] : data
                ) || [],
                temperature: sensorData.temperature || [],
                heartRate: sensorData.heartRate || [],
                gyroscope: sensorData.gyroscope?.map(data =>
                    data.length > 4 && data[4] === 1 ?
                        [data[0], data[1], data[2], data[3]] : data
                ) || [],
                magnetometer: sensorData.magnetometer?.map(data =>
                    data.length > 4 && data[4] === 1 ?
                        [data[0], data[1], data[2], data[3]] : data
                ) || [],
                ecg: sensorData.ecg || []
            }
        };

        // Actualizar estado
        this.storedRecordingsSignal.update(recordings => [newRecording, ...recordings]);

        // Guardar en localStorage
        try {
            this.saveToStorage();
        } catch (error) {
            console.error('Error guardando en localStorage:', error);
            this.handleStorageError(error);
        }

        return id;
    }

    /**
     * Maneja errores de almacenamiento
     */
    private handleStorageError(error: any): void {
        if (error instanceof DOMException && error.name === 'QuotaExceededError') {
            console.warn('localStorage lleno, reduciendo datos');

            // Reducir tamaño de datos limitando número de muestras
            this.storedRecordingsSignal.update(recordings => {
                return recordings.map(recording => ({
                    ...recording,
                    sensorData: {
                        accelerometer: this.trimArray(recording.sensorData.accelerometer, 50),
                        temperature: this.trimArray(recording.sensorData.temperature, 20),
                        heartRate: this.trimArray(recording.sensorData.heartRate, 20),
                        gyroscope: this.trimArray(recording.sensorData.gyroscope, 50),
                        magnetometer: this.trimArray(recording.sensorData.magnetometer, 50),
                        ecg: this.trimArray(recording.sensorData.ecg, 100)
                    }
                }));
            });

            // Intentar guardar nuevamente
            try {
                this.saveToStorage();
            } catch (retryError) {
                // Si aún falla, eliminar grabaciones antiguas
                if (this.storedRecordingsSignal().length > 1) {
                    this.storedRecordingsSignal.update(recordings =>
                        recordings.slice(0, Math.ceil(recordings.length / 2))
                    );
                    this.saveToStorage();
                }
            }
        }
    }

    /**
     * Recorta un array a una longitud máxima
     */
    private trimArray<T>(array: T[] | undefined, maxLength: number): T[] {
        if (!array) return [];
        return array.length > maxLength ? array.slice(0, maxLength) : array;
    }

    /**
     * Elimina una grabación por su ID
     */
    deleteRecording(id: string): boolean {
        const currentRecordings = this.storedRecordingsSignal();
        const initialLength = currentRecordings.length;

        this.storedRecordingsSignal.update(recordings =>
            recordings.filter(recording => recording.id !== id)
        );

        if (currentRecordings.length !== initialLength) {
            this.saveToStorage();
            return true;
        }

        return false;
    }

    /**
     * Renombra una grabación
     */
    renameRecording(id: string, name: string): boolean {
        let found = false;

        this.storedRecordingsSignal.update(recordings => {
            return recordings.map(recording => {
                if (recording.id === id) {
                    found = true;
                    return { ...recording, name };
                }
                return recording;
            });
        });

        if (found) {
            this.saveToStorage();
        }

        return found;
    }

    /**
     * Obtiene una grabación por su ID
     */
    getRecordingById(id: string): StoredMemoryRecording | undefined {
        return this.storedRecordingsSignal().find(recording => recording.id === id);
    }

    /**
     * Carga grabaciones desde el almacenamiento
     */
    private loadFromStorage(): void {
        try {
            const storedData = localStorage.getItem(STORAGE_KEY);
            if (storedData) {
                const parsedData = JSON.parse(storedData) as StoredMemoryRecording[];
                this.storedRecordingsSignal.set(parsedData);
            }
        } catch (error) {
            console.error('Error cargando grabaciones de memoria:', error);
        }
    }

    /**
     * Guarda grabaciones en el almacenamiento
     */
    private saveToStorage(): void {
        const dataToStore = JSON.stringify(this.storedRecordingsSignal());
        localStorage.setItem(STORAGE_KEY, dataToStore);
    }

    /**
     * Elimina todas las grabaciones
     */
    clearAllRecordings(): void {
        this.storedRecordingsSignal.set([]);
        localStorage.removeItem(STORAGE_KEY);
    }
}
---- src/app/app.component.scss ----
:host {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  font-family: sans-serif;
}

.app-header {
  background-color: #3f51b5;
  color: white;
  padding: 1rem 1.5rem;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);

  &__title {
    margin: 0;
    font-size: 1.5rem;
    font-weight: normal;
  }
}

.app-main {
  flex-grow: 1;
  padding: 1.5rem;
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

// Panel de Estado de Sensores
.sensor-panel {
  padding: 1rem;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  background-color: #fff;

  &__title {
    margin-top: 0;
    margin-bottom: 1rem;
    font-size: 1.2rem;
    font-weight: 500;
    color: #333;
  }

  &__status-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 0.75rem;
  }
}

.sensor-status {
  padding: 0.75rem;
  border-radius: 4px;
  border: 1px solid #eeeeee;
  background-color: #f9f9f9;
  transition: background-color 0.3s ease;

  &__name {
    font-weight: 500;
    color: #555;
    margin-right: 0.5rem;
  }

  &__value {
    text-transform: capitalize;
    color: #999;
  }

  &--active {
    background-color: #e8f5e9;
    border-color: #c8e6c9;

    .sensor-status__value {
      color: #2e7d32;
      font-weight: 500;
    }
  }

  &--error {
    background-color: #ffebee;
    border-color: #ffcdd2;

    .sensor-status__value {
      color: #c62828;
      font-weight: 500;
    }
  }
}

// Contenedor para todos los componentes de visualización de sensores
.sensor-data-area {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
  gap: 1.5rem;
  padding-top: 1rem;
}

// Sección de ECGs guardados
.stored-ecg-section {
  width: 100%;
  margin-top: 1rem;
}

.app-footer {
  background-color: #f5f5f5;
  color: #666;
  padding: 1rem 1.5rem;
  text-align: center;
  margin-top: auto;

  &__text {
    font-size: 0.9rem;
    margin: 0;
  }
}

// Ocultar router outlet si no se usa
router-outlet:empty {
  display: none;
}
.stored-memory-section {
  width: 100%;
  margin-top: 1rem;
}

---- src/app/app.routes.ts ----
import { Routes } from '@angular/router';

export const routes: Routes = [];

---- src/app/app.component.spec.ts ----
import { TestBed } from '@angular/core/testing';
import { AppComponent } from './app.component';

describe('AppComponent', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [AppComponent],
    }).compileComponents();
  });

  it('should create the app', () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

  it(`should have the 'nvdo-update' title`, () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app.title).toEqual('nvdo-update');
  });

  it('should render title', () => {
    const fixture = TestBed.createComponent(AppComponent);
    fixture.detectChanges();
    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('h1')?.textContent).toContain('Hello, nvdo-update');
  });
});

---- src/app/features/stored-ecg-viewer/stored-ecg-viewer.component.ts ----
import { Component, Input, inject, signal, SimpleChanges, OnChanges } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NgxChartsModule, ScaleType } from '@swimlane/ngx-charts';
import { MovesenseService } from '../../core/services/movesense.service';
import { StoredEcg } from '../../core/models/ecg-storage.model';

interface ChartData {
  name: string;
  series: ChartSeriesData[];
}

interface ChartSeriesData {
  name: string | Date;
  value: number;
}

@Component({
  selector: 'app-stored-ecg-viewer',
  standalone: true,
  imports: [CommonModule, NgxChartsModule],
  templateUrl: './stored-ecg-viewer.component.html',
  styleUrl: './stored-ecg-viewer.component.scss'
})
export class StoredEcgViewerComponent implements OnChanges {
  @Input() ecgId = '';

  private movesenseService = inject(MovesenseService);

  // Component state signals
  readonly ecgData = signal<StoredEcg | null>(null);
  readonly chartData = signal<ChartData[]>([{ name: 'ECG', series: [] }]);

  // Chart configuration
  readonly view: [number, number] = [700, 300];
  readonly legend = false;
  readonly showXAxisLabel = true;
  readonly showYAxisLabel = true;
  readonly xAxisLabel = 'Tiempo';
  readonly yAxisLabel = 'ECG (mV)';
  readonly timeline = true;
  readonly autoScale = true;
  readonly colorScheme = {
    name: 'ecgScheme',
    selectable: true,
    group: ScaleType.Ordinal,
    domain: ['#00BCD4']
  };

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['ecgId']) {
      this.loadEcgData();
    }
  }

  private loadEcgData(): void {
    if (!this.ecgId) {
      this.ecgData.set(null);
      this.chartData.set([{ name: 'ECG', series: [] }]);
      return;
    }

    const ecg = this.movesenseService.getEcgById(this.ecgId);

    if (!ecg) {
      this.ecgData.set(null);
      this.chartData.set([{ name: 'ECG', series: [] }]);
      return;
    }

    this.ecgData.set(ecg);
    this.generateChartData(ecg);
  }
  /**
   * Genera datos para visualización ECG médica
   * Mantiene precisión para uso clínico
   */
  private generateChartData(ecg: StoredEcg): void {
    const series: ChartSeriesData[] = [];
    const sampleRateHz = 128; // Frecuencia estándar Movesense ECG
    const timePerSampleMs = 1000 / sampleRateHz;

    // Factor de conversión µV específico para Movesense (mantener precisión)
    const LSB_UV = 0.38147;

    if (ecg.samples.length > 0) {
      let currentTimestampMs = ecg.timestamp;

      // Generar visualización con todos los puntos disponibles
      // En aplicaciones médicas es importante no omitir datos
      for (let i = 0; i < ecg.samples.length; i++) {
        const rawValue = ecg.samples[i];

        // Opción 1: Valor crudo (para desarrollo/depuración)
        // const value = rawValue;

        // Opción 2: Valor en µV (para uso médico/clínico)
        const value = rawValue * LSB_UV;

        series.push({
          name: new Date(currentTimestampMs),
          value: value
        });

        currentTimestampMs += timePerSampleMs;
      }
    }

    this.chartData.set([{ name: 'ECG', series }]);
  }
  // Axis formatting
  xAxisTickFormatting(val: string | Date): string {
    if (val instanceof Date) {
      return val.toLocaleTimeString([], {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 3
      });
    }
    return String(val);
  }
}
---- src/app/features/stored-ecg-viewer/stored-ecg-viewer.component.html ----
<div class="ecg-viewer">
    @if (ecgData()) {
    <div class="ecg-viewer__info">
        <div class="ecg-viewer__name">
            {{ ecgData()?.name || 'ECG sin nombre' }}
        </div>
        <div class="ecg-viewer__details">
            <span class="ecg-viewer__date">
                {{ ecgData()?.timestamp | date:'medium' }}
            </span>
            <span class="ecg-viewer__duration">
                Duración: {{ ecgData() ? ecgData()!.duration.toFixed(1) : 0 }}s
            </span>
            <span class="ecg-viewer__samples">
                Muestras: {{ ecgData() ? ecgData()!.samples.length : 0 }}
            </span>
        </div>
    </div>

    <div class="ecg-viewer__chart">
        @if (chartData()[0].series.length > 0) {
        <ngx-charts-line-chart class="ecg-viewer__chart-container" [view]="view" [scheme]="colorScheme"
            [results]="chartData()" [legend]="legend" [xAxis]="true" [yAxis]="true" [showXAxisLabel]="showXAxisLabel"
            [showYAxisLabel]="showYAxisLabel" [xAxisLabel]="xAxisLabel" [yAxisLabel]="yAxisLabel" [timeline]="timeline"
            [autoScale]="autoScale" [xAxisTickFormatting]="xAxisTickFormatting">
        </ngx-charts-line-chart>
        } @else {
        <div class="ecg-viewer__no-data">
            El ECG no contiene datos válidos
        </div>
        }
    </div>
    } @else {
    <div class="ecg-viewer__no-data">
        No se encontró el ECG solicitado
    </div>
    }
</div>
---- src/app/features/stored-ecg-viewer/stored-ecg-viewer.component.scss ----
.ecg-viewer {
  width: 100%;

  &__info {
    margin-bottom: 1rem;
  }

  &__name {
    font-size: 1.1rem;
    font-weight: 500;
    margin-bottom: 0.5rem;
  }

  &__details {
    display: flex;
    gap: 1rem;
    font-size: 0.9rem;
    color: #666;
  }

  &__date,
  &__duration,
  &__samples {
    &::after {
      content: "·";
      margin-left: 1rem;
      color: #bbb;
    }

    &:last-child::after {
      display: none;
    }
  }

  &__chart {
    border: 1px solid #eee;
    border-radius: 4px;
    padding: 1rem;
    min-height: 300px;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  &__chart-container {
    width: 100%;
    height: 300px;
  }

  &__no-data {
    color: #9e9e9e;
    font-style: italic;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 250px;
  }
}

---- src/app/features/ecg-chart/ecg-chart.component.ts ----
import { Component, inject, signal, effect, linkedSignal } from '@angular/core';
import { NgxChartsModule, ScaleType } from '@swimlane/ngx-charts';
import { CommonModule } from '@angular/common';
import { EcgData } from '../../core/models/sensor-data.model';
import { MovesenseService } from '../../core/services/movesense.service';

const MAX_ECG_DATA_POINTS = 500;

interface ChartData {
    name: string;
    series: ChartSeriesData[];
}

interface ChartSeriesData {
    name: string | Date;
    value: number;
}

@Component({
    selector: 'app-ecg-chart',
    templateUrl: './ecg-chart.component.html',
    styleUrls: ['./ecg-chart.component.scss'],
    standalone: true,
    imports: [NgxChartsModule, CommonModule]
})
export class EcgChartComponent {
    private movesenseService = inject(MovesenseService);

    // Chart data signal
    readonly chartData = signal<ChartData[]>([
        { name: 'ECG', series: [] }
    ]);

    // Link service signals directly
    readonly hasStoredEcgs = linkedSignal(this.movesenseService.hasStoredEcgs);
    readonly isConnected = linkedSignal(this.movesenseService.isConnected);
    readonly isRecording = linkedSignal(this.movesenseService.isEcgRecording);

    // Chart configuration
    readonly view: [number, number] = [700, 300];
    readonly legend = false;
    readonly showXAxisLabel = true;
    readonly showYAxisLabel = true;
    readonly xAxisLabel = 'Tiempo';
    readonly yAxisLabel = 'ECG (mV)';
    readonly timeline = true;
    readonly colorScheme = {
        name: 'ecgScheme',
        selectable: true,
        group: ScaleType.Ordinal,
        domain: ['#00BCD4']
    };
    readonly autoScale = true;

    constructor() {
        // Effect to update chart when new ECG data arrives
        effect(() => {
            const newEcgData = this.movesenseService.ecgData();
            if (newEcgData && this.isConnected() && newEcgData.samples.length > 0) {
                this.updateChart(newEcgData);
            }
        });

        // Effect to clear chart data when disconnected
        effect(() => {
            if (!this.isConnected()) {
                this.chartData.set([{ name: 'ECG', series: [] }]);
            }
        });
    }

    private updateChart(newData: EcgData): void {
        this.chartData.update(currentChartData => {
            const currentSeries = currentChartData[0].series;
            const newPoints: ChartSeriesData[] = [];

            // Sample rate should be known
            const sampleRateHz = 128;
            const timePerSampleMs = 1000 / sampleRateHz;
            let currentTimestampMs = newData.timestamp;

            for (const sample of newData.samples) {
                newPoints.push({
                    name: new Date(currentTimestampMs),
                    value: sample
                });
                currentTimestampMs += timePerSampleMs;
            }

            // Add new points and limit history length
            const updatedSeries = [...currentSeries, ...newPoints].slice(-MAX_ECG_DATA_POINTS);

            return [{ name: 'ECG', series: updatedSeries }];
        });
    }

    // Axis formatting
    xAxisTickFormatting(val: string | Date): string {
        if (val instanceof Date) {
            return val.toLocaleTimeString([], {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                fractionalSecondDigits: 3
            });
        }
        return String(val);
    }

    // Recording control methods
    startRecording(): void {
        this.movesenseService.startEcgRecording();
    }

    stopRecording(): void {
        this.movesenseService.stopEcgRecording();
    }
}
---- src/app/features/ecg-chart/ecg-chart.component.html ----
<div class="ecg-chart">
  <div class="ecg-chart__header">
    <h3 class="ecg-chart__title">ECG (mV)</h3>
    @if(isConnected()) {
    <div class="ecg-chart__controls">
      @if (isRecording()) {
      <button class="ecg-chart__button ecg-chart__button--stop" (click)="stopRecording()">
        Detener Grabación
      </button>
      } @else {
      <button class="ecg-chart__button ecg-chart__button--start" (click)="startRecording()">
        Iniciar Grabación
      </button>
      }
    </div>
    }
  </div>

  @if (isConnected()) {
  @if (chartData()[0].series.length > 0) {
  <ngx-charts-line-chart class="ecg-chart__chart-container" [view]="view" [scheme]="colorScheme" [results]="chartData()"
    [legend]="legend" [xAxis]="true" [yAxis]="true" [showXAxisLabel]="showXAxisLabel" [showYAxisLabel]="showYAxisLabel"
    [xAxisLabel]="xAxisLabel" [yAxisLabel]="yAxisLabel" [timeline]="timeline" [autoScale]="autoScale"
    [xAxisTickFormatting]="xAxisTickFormatting">
  </ngx-charts-line-chart>
  } @else {
  <div class="ecg-chart__nodata">Esperando datos de ECG...</div>
  }
  } @else {
  <div class="ecg-chart__disconnected">Conecta el dispositivo para ver el gráfico</div>
  }

  @if (hasStoredEcgs()) {
  <div class="ecg-chart__stored-info">
    <span class="ecg-chart__stored-badge">ECGs Guardados Disponibles</span>
  </div>
  }
</div>
---- src/app/features/ecg-chart/ecg-chart.component.scss ----
.ecg-chart {
  padding: 1rem;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  background-color: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;

  &__header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    margin-bottom: 0.5rem;
  }

  &__title {
    margin-top: 0;
    margin-bottom: 0;
    font-size: 1rem;
    font-weight: bold;
    color: #555;
  }

  &__controls {
    display: flex;
    gap: 0.5rem;
  }

  &__button {
    padding: 0.4rem 0.8rem;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9rem;
    transition: background-color 0.2s ease;
    color: white;

    &--start {
      background-color: #4caf50;

      &:hover {
        background-color: #45a049;
      }
    }

    &--stop {
      background-color: #f44336;

      &:hover {
        background-color: #e53935;
      }
    }
  }

  &__chart-container {
    width: 100%;
    height: 300px;
  }

  &__nodata,
  &__disconnected {
    font-size: 0.9rem;
    color: #aaa;
    font-style: italic;
    padding: 1rem 0;
    text-align: center;
    width: 100%;
    min-height: 100px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  &__stored-info {
    display: flex;
    width: 100%;
    justify-content: flex-end;
    margin-top: 0.5rem;
  }

  &__stored-badge {
    display: inline-block;
    padding: 0.3rem 0.6rem;
    background-color: #4caf50;
    color: white;
    border-radius: 4px;
    font-size: 0.8rem;
  }
}

---- src/app/features/hr-chart/hr-chart.component.html ----
<div class="hr-chart">
  <h3 class="hr-chart__title">Ritmo Cardíaco (BPM)</h3>
  @if (isConnected()) {
  @if (chartData()[0].series.length > 0) {
  <ngx-charts-line-chart class="hr-chart__chart-container" [view]="view" [scheme]="colorScheme" [results]="chartData()"
    [legend]="legend" [xAxis]="true" [yAxis]="true" [showXAxisLabel]="showXAxisLabel" [showYAxisLabel]="showYAxisLabel"
    [xAxisLabel]="xAxisLabel" [yAxisLabel]="yAxisLabel" [timeline]="timeline" [autoScale]="autoScale"
    [xAxisTickFormatting]="xAxisTickFormatting">
  </ngx-charts-line-chart>
  } @else {
  <div class="hr-chart__nodata">Esperando datos de ritmo cardíaco...</div>
  }
  } @else {
  <div class="hr-chart__disconnected">Conecta el dispositivo para ver el gráfico</div>
  }
</div>
---- src/app/features/hr-chart/hr-chart.component.scss ----
.hr-chart {
  padding: 1rem;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  background-color: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;

  &__title {
    margin-top: 0;
    margin-bottom: 1rem;
    font-size: 1rem;
    font-weight: bold;
    color: #555;
    align-self: flex-start;
  }

  &__chart-container {
    width: 100%;
    height: 300px;
  }

  &__nodata,
  &__disconnected {
    font-size: 0.9rem;
    color: #aaa;
    font-style: italic;
    padding: 1rem 0;
    text-align: center;
    width: 100%;
    min-height: 100px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
}

---- src/app/features/hr-chart/hr-chart.component.ts ----
import { Component, inject, signal, effect, linkedSignal } from '@angular/core';
import { NgxChartsModule, ScaleType } from '@swimlane/ngx-charts';
import { CommonModule } from '@angular/common';
import { MovesenseService } from '../../core/services/movesense.service';
import { HeartRateData } from '../../core/models/sensor-data.model';

// Chart data interfaces
interface ChartData {
    name: string;
    series: ChartSeriesData[];
}

interface ChartSeriesData {
    name: string | Date;
    value: number;
}

const MAX_DATA_POINTS = 60;

@Component({
    selector: 'app-hr-chart',
    templateUrl: './hr-chart.component.html',
    styleUrls: ['./hr-chart.component.scss'],
    standalone: true,
    imports: [NgxChartsModule, CommonModule]
})
export class HrChartComponent {
    private movesenseService = inject(MovesenseService);

    // Chart data signal
    readonly chartData = signal<ChartData[]>([{ name: 'Ritmo Cardíaco', series: [] }]);

    // Link connection status signal
    readonly isConnected = linkedSignal(this.movesenseService.isConnected);

    // Chart configuration
    readonly view: [number, number] = [700, 300];
    readonly legend = false;
    readonly showXAxisLabel = true;
    readonly showYAxisLabel = true;
    readonly xAxisLabel = 'Tiempo';
    readonly yAxisLabel = 'Ritmo Cardíaco (BPM)';
    readonly timeline = true;
    readonly colorScheme = {
        name: 'hrScheme',
        selectable: true,
        group: ScaleType.Ordinal,
        domain: ['#E44D25']
    };
    readonly autoScale = true;

    constructor() {
        // Effect to update chart data when new HR data arrives
        effect(() => {
            const newHrData = this.movesenseService.heartRateData();
            if (newHrData && this.isConnected()) {
                this.updateChart(newHrData);
            }
        });

        // Effect to clear chart data when disconnected
        effect(() => {
            if (!this.isConnected()) {
                this.chartData.set([{ name: 'Ritmo Cardíaco', series: [] }]);
            }
        });
    }

    private updateChart(newData: HeartRateData): void {
        this.chartData.update(currentChartData => {
            const series = currentChartData[0].series;
            const newPoint: ChartSeriesData = {
                name: new Date(newData.timestamp),
                value: newData.hr
            };

            // Add new point and limit history length
            const updatedSeries = [...series, newPoint].slice(-MAX_DATA_POINTS);

            return [{ name: 'Ritmo Cardíaco', series: updatedSeries }];
        });
    }

    // Custom formatting for X-axis ticks
    xAxisTickFormatting(val: string | Date): string {
        if (val instanceof Date) {
            return val.toLocaleTimeString();
        }
        return String(val);
    }
}
---- src/app/features/connection/connection.component.ts ----
import { Component, inject, linkedSignal } from '@angular/core';
import { MovesenseService } from '../../core/services/movesense.service';
import { CommonModule } from '@angular/common';

@Component({
    selector: 'app-connection',
    templateUrl: './connection.component.html',
    styleUrls: ['./connection.component.scss'],
    standalone: true,
    imports: [CommonModule]
})
export class ConnectionComponent {
    private movesenseService = inject(MovesenseService);

    readonly isConnected = linkedSignal(this.movesenseService.isConnected);
    readonly deviceName = linkedSignal(this.movesenseService.deviceName);
    readonly connectionError = linkedSignal(this.movesenseService.connectionError);

    connect(): void {
        this.movesenseService.connect();
    }

    disconnect(): void {
        this.movesenseService.disconnect();
    }
}
---- src/app/features/connection/connection.component.scss ----
.connection {
  padding: 1rem;
  border: 1px solid #ccc;
  border-radius: 4px;
  margin-bottom: 1rem;
  background-color: #f9f9f9;
  font-family: sans-serif;

  &__title {
    margin-top: 0;
    margin-bottom: 0.75rem;
    font-size: 1.25rem;
    color: #333;
  }

  &__status {
    padding: 0.5rem;
    margin-bottom: 0.75rem;
    border-radius: 3px;
    font-weight: bold;

    &--connected {
      background-color: #e8f5e9;
      color: #2e7d32;
      border: 1px solid #a5d6a7;
    }

    &--disconnected {
      background-color: #fff3e0;
      color: #ef6c00;
      border: 1px solid #ffcc80;
    }

    &--error {
      background-color: #ffebee;
      color: #c62828;
      border: 1px solid #ef9a9a;
    }
  }

  &__button {
    padding: 0.6rem 1rem;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
    transition: background-color 0.2s ease;

    &--connect {
      background-color: #007bff;
      color: white;

      &:hover:not(:disabled) {
        background-color: #0056b3;
      }

      &:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
      }
    }

    &--disconnect {
      background-color: #dc3545;
      color: white;

      &:hover {
        background-color: #c82333;
      }
    }
  }
}

---- src/app/features/connection/connection.component.html ----
<div class="connection">
  <h2 class="connection__title">Conexión Movesense</h2>

  @if (connectionError(); as error) {
  <div class="connection__status connection__status--error">
    Error: {{ error }}
  </div>
  }

  @if (isConnected()) {
  <div class="connection__status connection__status--connected">
    Conectado a: {{ deviceName() || 'Dispositivo Movesense' }}
  </div>
  <button class="connection__button connection__button--disconnect" (click)="disconnect()">
    Desconectar
  </button>
  } @else {
  <div class="connection__status connection__status--disconnected">
    Desconectado
  </div>
  <button class="connection__button connection__button--connect" (click)="connect()" [disabled]="isConnected()">
    Conectar a Movesense
  </button>
  }
</div>
---- src/app/features/memory-recording/memory-recording.component.ts ----

import { Component, inject, signal, effect, OnDestroy, linkedSignal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MovesenseService } from '../../core/services/movesense.service';

@Component({
  selector: 'app-memory-recording',
  standalone: true,
  imports: [CommonModule],
  templateUrl: './memory-recording.component.html',
  styleUrls: ['./memory-recording.component.scss']
})
export class MemoryRecordingComponent implements OnDestroy {
  private movesenseService = inject(MovesenseService);

  // Link signals from service utilizando linkedSignal
  readonly isConnected = linkedSignal(this.movesenseService.isConnected);
  readonly isRecording = linkedSignal(this.movesenseService.isMemoryRecording);
  readonly recordingStatus = linkedSignal(this.movesenseService.memoryRecordingStatus);
  readonly hasStoredRecordings = linkedSignal(this.movesenseService.hasStoredMemoryRecordings);
  readonly bytesDownloaded = linkedSignal(this.movesenseService.bytesDownloaded);

  // Contador de tiempo transcurrido
  readonly secondsElapsed = signal<number>(0);
  private timerInterval: number | null = null;

  constructor() {
    // Efecto para monitorear cambios en el estado de grabación
    effect(() => {
      const status = this.recordingStatus();

      // Si comienza a grabar, iniciar el contador
      if (status === 'recording' && !this.timerInterval) {
        this.secondsElapsed.set(0);
        this.startTimer();
      }

      // Si deja de grabar, detener el contador
      if (status !== 'recording' && this.timerInterval) {
        this.stopTimer();
      }
    });
  }

  startRecording(): void {
    console.log('Iniciando grabación en memoria desde componente');
    this.movesenseService.startMemoryRecording();
  }

  stopRecording(): void {
    console.log('Deteniendo grabación en memoria desde componente');
    this.movesenseService.stopMemoryRecording();
  }

  private startTimer(): void {
    if (this.timerInterval !== null) {
      window.clearInterval(this.timerInterval);
    }

    this.timerInterval = window.setInterval(() => {
      this.secondsElapsed.update(val => val + 1);
    }, 1000);
  }

  private stopTimer(): void {
    if (this.timerInterval !== null) {
      window.clearInterval(this.timerInterval);
      this.timerInterval = null;
    }
  }

  ngOnDestroy(): void {
    this.stopTimer();
  }
}
---- src/app/features/memory-recording/memory-recording.component.html ----
<div class="memory-recording">
    <div class="memory-recording__header">
        <h3 class="memory-recording__title">Grabación en Memoria</h3>
        @if(isConnected()) {
        <div class="memory-recording__controls">
            @if (isRecording()) {
            <button class="memory-recording__button memory-recording__button--stop" (click)="stopRecording()">
                Detener Grabación ({{ secondsElapsed() }}s)
            </button>
            } @else if (recordingStatus() === 'downloading') {
            <div class="memory-recording__status memory-recording__status--downloading">
                Descargando datos ({{ bytesDownloaded() }} bytes)
            </div>
            } @else {
            <button class="memory-recording__button memory-recording__button--start" (click)="startRecording()">
                Iniciar Grabación en Memoria
            </button>
            }
        </div>
        }
    </div>

    @if (isConnected()) {
    @if (recordingStatus() === 'recording') {
    <div class="memory-recording__info memory-recording__info--recording">
        <div class="memory-recording__recording-indicator"></div>
        <span>Grabando datos en la memoria del dispositivo... ({{ secondsElapsed() }}s)</span>
        <p class="memory-recording__description">
            El dispositivo está grabando datos de los sensores en su memoria interna.
            Los datos se guardarán incluso si se pierde la conexión Bluetooth.
        </p>
    </div>
    } @else if (recordingStatus() === 'downloading') {
    <div class="memory-recording__info memory-recording__info--downloading">
        <div class="memory-recording__spinner"></div>
        <span>Descargando datos del dispositivo... ({{ bytesDownloaded() }} bytes)</span>
    </div>
    } @else {
    <div class="memory-recording__info">
        <p>
            Utiliza esta función para grabar datos de sensores directamente en la
            memoria del dispositivo, incluso cuando no hay conexión Bluetooth activa.
        </p>
    </div>
    }
    } @else {
    <div class="memory-recording__disconnected">
        Conecta el dispositivo para usar la grabación en memoria
    </div>
    }

    @if (hasStoredRecordings()) {
    <div class="memory-recording__stored-info">
        <span class="memory-recording__stored-badge">Grabaciones Guardadas Disponibles</span>
    </div>
    }
</div>
---- src/app/features/memory-recording/memory-recording.component.scss ----
/* src/app/features/memory-recording/memory-recording.component.scss */
.memory-recording {
  padding: 1rem;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  background-color: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;

  &__header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    margin-bottom: 0.5rem;
  }

  &__title {
    margin-top: 0;
    margin-bottom: 0;
    font-size: 1rem;
    font-weight: bold;
    color: #555;
  }

  &__controls {
    display: flex;
    gap: 0.5rem;
  }

  &__button {
    padding: 0.4rem 0.8rem;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9rem;
    transition: background-color 0.2s ease;
    color: white;

    &--start {
      background-color: #4caf50;

      &:hover {
        background-color: #45a049;
      }
    }

    &--stop {
      background-color: #f44336;

      &:hover {
        background-color: #e53935;
      }
    }
  }

  &__info {
    width: 100%;
    padding: 1rem;
    margin-top: 1rem;
    text-align: center;
    border-radius: 4px;
    font-size: 0.9rem;
    color: #666;

    &--recording {
      background-color: #e8f5e9;
      color: #2e7d32;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.5rem;
    }

    &--downloading {
      background-color: #e3f2fd;
      color: #1565c0;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }
  }

  &__recording-indicator {
    width: 12px;
    height: 12px;
    background-color: #f44336;
    border-radius: 50%;
    animation: blink 1s ease-in-out infinite alternate;
  }

  &__spinner {
    width: 16px;
    height: 16px;
    border: 2px solid #1565c0;
    border-top: 2px solid transparent;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  &__description {
    font-size: 0.8rem;
    color: #555;
    margin-top: 0.5rem;
  }

  &__disconnected {
    font-size: 0.9rem;
    color: #aaa;
    font-style: italic;
    padding: 1rem 0;
    text-align: center;
    width: 100%;
  }

  &__stored-info {
    display: flex;
    width: 100%;
    justify-content: flex-end;
    margin-top: 0.5rem;
  }

  &__status {
    padding: 0.4rem 0.8rem;
    border-radius: 4px;
    font-size: 0.9rem;
    display: flex;
    align-items: center;

    &--downloading {
      background-color: #e3f2fd;
      color: #1565c0;
    }
  }

  &__stored-badge {
    display: inline-block;
    padding: 0.3rem 0.6rem;
    background-color: #4caf50;
    color: white;
    border-radius: 4px;
    font-size: 0.8rem;
  }
}

@keyframes blink {
  from {
    opacity: 1;
  }
  to {
    opacity: 0.5;
  }
}

@keyframes spin {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

---- src/app/features/stored-ecg-list/stored-ecg-list.component.scss ----
.stored-ecg {
  padding: 1rem;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  background-color: #fff;
  width: 100%;

  &__title {
    margin-top: 0;
    margin-bottom: 1rem;
    font-size: 1.2rem;
    font-weight: 500;
    color: #333;
  }

  &__container {
    display: flex;
    gap: 1.5rem;

    @media (max-width: 768px) {
      flex-direction: column;
    }
  }

  &__list {
    flex: 1;
    max-width: 300px;
    border-right: 1px solid #eee;
    padding-right: 1rem;

    @media (max-width: 768px) {
      max-width: 100%;
      border-right: none;
      border-bottom: 1px solid #eee;
      padding-right: 0;
      padding-bottom: 1rem;
      margin-bottom: 1rem;
    }
  }

  &__item {
    padding: 0.8rem;
    border: 1px solid #eee;
    border-radius: 4px;
    margin-bottom: 0.6rem;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: background-color 0.2s ease;

    &:hover {
      background-color: #f9f9f9;
    }

    &--selected {
      background-color: #e3f2fd;
      border-color: #bbdefb;

      &:hover {
        background-color: #e3f2fd;
      }
    }
  }

  &__item-info {
    flex: 1;
  }

  &__item-name {
    font-weight: 500;
    margin-bottom: 0.3rem;
  }

  &__item-date {
    font-size: 0.8rem;
    color: #666;
  }

  &__item-duration {
    font-size: 0.8rem;
    color: #666;
  }

  &__delete-btn {
    background-color: transparent;
    color: #f44336;
    border: none;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    font-size: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    margin-left: 0.5rem;

    &:hover {
      background-color: rgba(244, 67, 54, 0.1);
    }
  }

  &__details {
    flex: 2;
    display: flex;
    flex-direction: column;
  }

  &__name-edit {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
  }

  &__name-input {
    flex: 1;
    padding: 0.5rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 0.9rem;
  }

  &__save-btn {
    padding: 0.5rem 1rem;
    background-color: #4caf50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;

    &:hover:not(:disabled) {
      background-color: #43a047;
    }

    &:disabled {
      background-color: #a5d6a7;
      cursor: not-allowed;
    }
  }

  &__viewer {
    flex: 1;
    min-height: 300px;
  }

  &__no-selection {
    flex: 2;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #9e9e9e;
    font-style: italic;
    min-height: 300px;
    border: 1px dashed #e0e0e0;
    border-radius: 4px;
  }

  &__empty {
    color: #9e9e9e;
    font-style: italic;
    padding: 2rem;
    text-align: center;
    border: 1px dashed #e0e0e0;
    border-radius: 4px;
  }
}

---- src/app/features/stored-ecg-list/stored-ecg-list.component.html ----
<div class="stored-ecg">
    <h3 class="stored-ecg__title">ECG Guardados</h3>

    @if (hasStoredEcgs()) {
    <div class="stored-ecg__container">
        <div class="stored-ecg__list">
            @for (ecg of storedEcgs(); track ecg.id) {
            <div class="stored-ecg__item" [class.stored-ecg__item--selected]="selectedEcgId() === ecg.id"
                (click)="selectEcg(ecg.id)">
                <div class="stored-ecg__item-info">
                    <div class="stored-ecg__item-name">
                        {{ ecg.name || 'ECG sin nombre' }}
                    </div>
                    <div class="stored-ecg__item-date">
                        {{ formatDateShort(ecg.timestamp) }}
                    </div>
                    <div class="stored-ecg__item-duration">
                        Duración: {{ formatDuration(ecg.duration) }}
                    </div>
                </div>
                <button class="stored-ecg__delete-btn" (click)="deleteEcg(ecg.id, $event)" aria-label="Eliminar ECG">
                    ✕
                </button>
            </div>
            }
        </div>

        @if (selectedEcgId()) {
        <div class="stored-ecg__details">
            <div class="stored-ecg__name-edit">
                <input type="text" class="stored-ecg__name-input" [ngModel]="newEcgName()"
                    (ngModelChange)="newEcgName.set($event)" placeholder="Nombre del ECG" />
                <button class="stored-ecg__save-btn" (click)="saveEcgName()" [disabled]="!newEcgName()">
                    Guardar
                </button>
            </div>

            <app-stored-ecg-viewer [ecgId]="selectedEcgId() || ''" class="stored-ecg__viewer">
            </app-stored-ecg-viewer>
        </div>
        } @else {
        <div class="stored-ecg__no-selection">
            Selecciona un ECG para visualizarlo
        </div>
        }
    </div>
    } @else {
    <div class="stored-ecg__empty">
        No hay ECGs guardados. Utilice la función de grabación en la pantalla de ECG.
    </div>
    }
</div>
---- src/app/features/stored-ecg-list/stored-ecg-list.component.ts ----
import { Component, inject, signal, linkedSignal } from '@angular/core';
import { CommonModule, DatePipe } from '@angular/common';
import { StoredEcg } from '../../core/models/ecg-storage.model';
import { MovesenseService } from '../../core/services/movesense.service';
import { FormsModule } from '@angular/forms';
import { StoredEcgViewerComponent } from '../stored-ecg-viewer/stored-ecg-viewer.component';

@Component({
  selector: 'app-stored-ecg-list',
  standalone: true,
  imports: [CommonModule, DatePipe, FormsModule, StoredEcgViewerComponent],
  templateUrl: './stored-ecg-list.component.html',
  styleUrl: './stored-ecg-list.component.scss'
})
export class StoredEcgListComponent {
  private movesenseService = inject(MovesenseService);

  // Link storage signals
  readonly storedEcgs = linkedSignal(this.movesenseService.storedEcgs);
  readonly hasStoredEcgs = linkedSignal(this.movesenseService.hasStoredEcgs);

  // Component state signals
  readonly selectedEcgId = signal<string | null>(null);
  readonly newEcgName = signal<string>('');

  selectEcg(id: string): void {
    if (this.selectedEcgId() === id) {
      this.selectedEcgId.set(null);
    } else {
      this.selectedEcgId.set(id);

      // Set default name from selected ECG
      const ecg = this.movesenseService.getEcgById(id);
      if (ecg) {
        this.newEcgName.set(ecg.name || '');
      }
    }
  }

  saveEcgName(): void {
    const id = this.selectedEcgId();
    if (id && this.newEcgName()) {
      this.movesenseService.saveStoredEcg(this.newEcgName(), id);
    }
  }

  deleteEcg(id: string, event: Event): void {
    event.stopPropagation(); // Prevent selection on delete

    if (confirm('¿Estás seguro de que deseas eliminar este ECG?')) {
      this.movesenseService.deleteStoredEcg(id);

      if (this.selectedEcgId() === id) {
        this.selectedEcgId.set(null);
      }
    }
  }

  formatDateShort(timestamp: number): string {
    const date = new Date(timestamp);
    return `${date.toLocaleDateString()} ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
  }

  formatDuration(seconds: number): string {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
  }
}
---- src/app/features/metrics-display/metrics-display.component.html ----
<div class="metrics-display">
  <h3 class="metrics-display__title">Métricas Calculadas</h3>
  @if (isConnected()) {
  <div class="metrics-display__grid">
    <div class="metrics-display__item">
      <span class="metrics-display__label">Pasos:</span>
      <span class="metrics-display__value">{{ steps() }}</span>
    </div>
    <div class="metrics-display__item">
      <span class="metrics-display__label">Distancia:</span>
      <span class="metrics-display__value">{{ distance() | number:'1.0-1' }} m</span>
    </div>
    <div class="metrics-display__item">
      <span class="metrics-display__label">Postura:</span>
      <span class="metrics-display__value metrics-display__value--posture-{{posture()}}">{{ posture() }}</span>
    </div>
    <div class="metrics-display__item">
      <span class="metrics-display__label">HRV (RMSSD):</span>
      <span class="metrics-display__value">{{ hrvRmssd() ?? 'N/A' }} ms</span>
    </div>
    <div class="metrics-display__item">
      <span class="metrics-display__label">Nivel de Estrés:</span>
      @if (stressLevel() !== null) {
      <span class="metrics-display__value">{{ stressLevel() }} %</span>
      <div class="metrics-display__stress-bar">
        <div class="metrics-display__stress-fill" [style.width.%]="stressLevel()"></div>
      </div>
      } @else {
      <span class="metrics-display__value">N/A</span>
      }
    </div>

    <!-- Estado de Detección de Caídas -->
    <div class="metrics-display__item">
      <span class="metrics-display__label">Caída Detectada:</span>
      <span class="metrics-display__value" [class.metrics-display__value--alert]="fallDetected()">
        {{ fallDetected() ? '¡SÍ - ALERTA!' : 'No' }}
      </span>
    </div>
    <!-- Timestamp de Última Caída -->
    <div class="metrics-display__item">
      <span class="metrics-display__label">Última Caída:</span>
      <span class="metrics-display__value">{{ formatFallTime(lastFallTimestamp()) }}</span>
    </div>

    <!-- Métricas de actividad -->
    <div class="metrics-display__item">
      <span class="metrics-display__label">Regates:</span>
      <span class="metrics-display__value">{{ dribbleCount() }}</span>
    </div>
    <div class="metrics-display__item">
      <span class="metrics-display__label">Calorías (Est.):</span>
      <span class="metrics-display__value">{{ caloriesBurned() }} kcal</span>
    </div>
  </div>
  } @else {
  <div class="metrics-display__disconnected">Conecta el dispositivo para ver métricas</div>
  }
</div>
---- src/app/features/metrics-display/metrics-display.component.scss ----
.metrics-display {
  padding: 1rem;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  background-color: #fff;

  &__title {
    margin-top: 0;
    margin-bottom: 1rem;
    font-size: 1rem;
    font-weight: bold;
    color: #555;
  }

  &__grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 0.75rem 1rem;
  }

  &__item {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
  }

  &__label {
    font-size: 0.8rem;
    color: #777;
    margin-bottom: 0.15rem;
  }

  &__value {
    font-size: 1.2rem;
    font-weight: 500;
    color: #333;

    &--posture-standing {
      color: #4caf50;
    }
    &--posture-stooped {
      color: #ff9800;
    }
    &--posture-lying {
      color: #2196f3;
    }
    &--posture-unknown {
      color: #9e9e9e;
    }

    &--alert {
      color: #f44336;
      animation: blink 1s ease-in-out infinite alternate;
    }
  }

  &__stress-bar {
    width: 100%;
    height: 8px;
    background-color: #eee;
    border-radius: 4px;
    overflow: hidden;
    margin-top: 0.25rem;
  }

  &__stress-fill {
    height: 100%;
    background-color: #f44336;
    border-radius: 4px 0 0 4px;
    transition: width 0.3s ease-in-out;
  }

  &__disconnected {
    font-size: 0.9rem;
    color: #aaa;
    font-style: italic;
    padding: 1rem 0;
    text-align: center;
  }
}

@keyframes blink {
  from {
    opacity: 1;
  }
  to {
    opacity: 0.5;
  }
}

---- src/app/features/metrics-display/metrics-display.component.ts ----
import { Component, inject, linkedSignal } from '@angular/core';
import { CommonModule, DecimalPipe, DatePipe } from '@angular/common';
import { MovesenseService } from '../../core/services/movesense.service';

@Component({
    selector: 'app-metrics-display',
    templateUrl: './metrics-display.component.html',
    styleUrls: ['./metrics-display.component.scss'],
    standalone: true,
    imports: [CommonModule, DecimalPipe, DatePipe]
})
export class MetricsDisplayComponent {
    private movesenseService = inject(MovesenseService);

    // Link all metrics signals directly from the service
    readonly steps = linkedSignal(this.movesenseService.steps);
    readonly distance = linkedSignal(this.movesenseService.distance);
    readonly posture = linkedSignal(this.movesenseService.posture);
    readonly hrvRmssd = linkedSignal(this.movesenseService.hrvRmssd);
    readonly stressLevel = linkedSignal(this.movesenseService.stressLevel);
    readonly dribbleCount = linkedSignal(this.movesenseService.dribbleCount);
    readonly caloriesBurned = linkedSignal(this.movesenseService.caloriesBurned);
    readonly fallDetected = linkedSignal(this.movesenseService.fallDetected);
    readonly lastFallTimestamp = linkedSignal(this.movesenseService.lastFallTimestamp);
    readonly isConnected = linkedSignal(this.movesenseService.isConnected);

    // Helper method for formatting fall timestamp
    formatFallTime(timestamp: number | null): string {
        if (timestamp === null) return 'Ninguna detectada';
        const date = new Date(timestamp);
        return date.toLocaleTimeString();
    }
}
---- src/app/features/temperature-display/temperature-display.component.ts ----
import { Component, inject, linkedSignal } from '@angular/core';
import { CommonModule, DecimalPipe, DatePipe } from '@angular/common';
import { MovesenseService } from '../../core/services/movesense.service';

@Component({
    selector: 'app-temperature-display',
    templateUrl: './temperature-display.component.html',
    styleUrls: ['./temperature-display.component.scss'],
    standalone: true,
    imports: [CommonModule, DecimalPipe, DatePipe]
})
export class TemperatureDisplayComponent {
    private movesenseService = inject(MovesenseService);

    // Link signals directly from service
    readonly temperatureData = linkedSignal(this.movesenseService.temperatureData);
    readonly isConnected = linkedSignal(this.movesenseService.isConnected);
}
---- src/app/features/temperature-display/temperature-display.component.scss ----
.temperature-display {
  padding: 1rem;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  background-color: #fff;
  text-align: center;
  min-width: 150px;

  &__title {
    margin-top: 0;
    margin-bottom: 0.75rem;
    font-size: 1rem;
    font-weight: bold;
    color: #555;
  }

  &__value {
    font-size: 1.8rem;
    font-weight: bold;
    color: #3f51b5;
    margin-bottom: 0.25rem;
  }

  &__timestamp {
    font-size: 0.75rem;
    color: #999;
  }

  &__nodata,
  &__disconnected {
    font-size: 0.9rem;
    color: #aaa;
    font-style: italic;
    padding: 1rem 0;
  }
}

---- src/app/features/temperature-display/temperature-display.component.html ----
<div class="temperature-display">
  <h3 class="temperature-display__title">Temperatura</h3>
  @if (isConnected()) {
  @if (temperatureData(); as data) {
  <div class="temperature-display__value">
    {{ data.measurement | number:'1.1-2' }} °C
  </div>
  <div class="temperature-display__timestamp">
    Última actualización: {{ data.timestamp | date:'mediumTime' }}
  </div>
  } @else {
  <div class="temperature-display__nodata">Esperando datos...</div>
  }
  } @else {
  <div class="temperature-display__disconnected">Conecta el dispositivo para ver datos</div>
  }
</div>
---- src/app/features/gyro-display/gyro-display.component.html ----
<div class="gyro-display">
  <h3 class="gyro-display__title">Giroscopio (°/s)</h3>
  @if (isConnected()) {
  @if (latestSample(); as sample) {
  <div class="gyro-display__data">
    <div class="gyro-display__values">
      <span class="gyro-display__axis">X: {{ sample.x | number:'1.2-2' }}</span>
      <span class="gyro-display__axis">Y: {{ sample.y | number:'1.2-2' }}</span>
      <span class="gyro-display__axis">Z: {{ sample.z | number:'1.2-2' }}</span>
    </div>
  </div>
  } @else {
  <div class="gyro-display__nodata">Esperando datos...</div>
  }
  } @else {
  <div class="gyro-display__disconnected">Conecta el dispositivo para ver datos</div>
  }
</div>
---- src/app/features/gyro-display/gyro-display.component.scss ----
.gyro-display {
  padding: 1rem;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  background-color: #fff;
  text-align: center;
  min-width: 150px;

  &__title {
    margin-top: 0;
    margin-bottom: 0.75rem;
    font-size: 1rem;
    font-weight: bold;
    color: #555;
  }

  &__data {
    font-size: 0.9rem;
    color: #333;
    padding: 1rem 0;
  }

  &__values {
    display: flex;
    justify-content: space-around;
    width: 100%;
    font-size: 1rem;
    font-weight: 500;
    color: #333;
    margin-top: 0.5rem;
  }

  &__axis {
    flex-basis: 30%;
    text-align: center;
  }

  &__nodata,
  &__disconnected {
    font-size: 0.9rem;
    color: #aaa;
    font-style: italic;
    padding: 1rem 0;
  }
}

---- src/app/features/gyro-display/gyro-display.component.ts ----
import { Component, inject, computed, linkedSignal } from '@angular/core';
import { CommonModule, DecimalPipe } from '@angular/common';
import { MovesenseService } from '../../core/services/movesense.service';

@Component({
    selector: 'app-gyro-display',
    templateUrl: './gyro-display.component.html',
    styleUrls: ['./gyro-display.component.scss'],
    standalone: true,
    imports: [CommonModule, DecimalPipe]
})
export class GyroDisplayComponent {
    private movesenseService = inject(MovesenseService);

    // Link signals from service
    readonly gyroData = linkedSignal(this.movesenseService.gyroscopeData);
    readonly isConnected = linkedSignal(this.movesenseService.isConnected);

    // Computed for latest sample data
    readonly latestSample = computed(() => {
        const data = this.gyroData();
        if (data && data.samples && data.samples.length > 0) {
            return data.samples[data.samples.length - 1];
        }
        return null;
    });
}
---- src/app/features/magn-display/magn-display.component.scss ----
.magn-display {
  padding: 1rem;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  background-color: #fff;
  text-align: center;
  min-width: 150px;

  &__title {
    margin-top: 0;
    margin-bottom: 0.75rem;
    font-size: 1rem;
    font-weight: bold;
    color: #555;
  }

  &__data {
    font-size: 0.9rem;
    color: #333;
    padding: 1rem 0;
  }

  &__values {
    display: flex;
    justify-content: space-around;
    width: 100%;
    font-size: 1rem;
    font-weight: 500;
    color: #333;
    margin-top: 0.5rem;
  }

  &__axis {
    flex-basis: 30%;
    text-align: center;
  }

  &__nodata,
  &__disconnected {
    font-size: 0.9rem;
    color: #aaa;
    font-style: italic;
    padding: 1rem 0;
  }
}

---- src/app/features/magn-display/magn-display.component.html ----
<div class="magn-display">
  <h3 class="magn-display__title">Magnetómetro (µT)</h3>
  @if (isConnected()) {
  @if (latestSample(); as sample) {
  <div class="magn-display__data">
    <div class="magn-display__values">
      <span class="magn-display__axis">X: {{ sample.x | number:'1.2-2' }}</span>
      <span class="magn-display__axis">Y: {{ sample.y | number:'1.2-2' }}</span>
      <span class="magn-display__axis">Z: {{ sample.z | number:'1.2-2' }}</span>
    </div>
  </div>
  } @else {
  <div class="magn-display__nodata">Esperando datos...</div>
  }
  } @else {
  <div class="magn-display__disconnected">Conecta el dispositivo para ver datos</div>
  }
</div>
---- src/app/features/magn-display/magn-display.component.ts ----
import { Component, inject, computed, linkedSignal } from '@angular/core';
import { CommonModule, DecimalPipe } from '@angular/common';
import { MovesenseService } from '../../core/services/movesense.service';

@Component({
    selector: 'app-magn-display',
    templateUrl: './magn-display.component.html',
    styleUrls: ['./magn-display.component.scss'],
    standalone: true,
    imports: [CommonModule, DecimalPipe]
})
export class MagnDisplayComponent {
    private movesenseService = inject(MovesenseService);

    // Link signals from service
    readonly magnData = linkedSignal(this.movesenseService.magnetometerData);
    readonly isConnected = linkedSignal(this.movesenseService.isConnected);

    // Computed for latest sample data
    readonly latestSample = computed(() => {
        const data = this.magnData();
        if (data && data.samples && data.samples.length > 0) {
            return data.samples[data.samples.length - 1];
        }
        return null;
    });
}
---- src/app/features/acc-chart/acc-chart.component.scss ----
.acc-chart {
  padding: 1rem;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  background-color: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;

  &__title {
    margin-top: 0;
    margin-bottom: 1rem;
    font-size: 1rem;
    font-weight: bold;
    color: #555;
    align-self: flex-start;
  }

  &__chart-container {
    width: 100%;
    height: 300px;
  }

  &__nodata,
  &__disconnected {
    font-size: 0.9rem;
    color: #aaa;
    font-style: italic;
    padding: 1rem 0;
    text-align: center;
    width: 100%;
    min-height: 100px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
}

---- src/app/features/acc-chart/acc-chart.component.html ----
<div class="acc-chart">
  <h3 class="acc-chart__title">Acelerómetro (m/s²)</h3>
  @if (isConnected()) {
  @if (chartData()[0].series.length > 0) {
  <ngx-charts-line-chart class="acc-chart__chart-container" [view]="view" [scheme]="colorScheme" [results]="chartData()"
    [legend]="legend" [xAxis]="true" [yAxis]="true" [showXAxisLabel]="showXAxisLabel" [showYAxisLabel]="showYAxisLabel"
    [xAxisLabel]="xAxisLabel" [yAxisLabel]="yAxisLabel" [timeline]="timeline" [autoScale]="autoScale"
    [xAxisTickFormatting]="xAxisTickFormatting">
  </ngx-charts-line-chart>
  } @else {
  <div class="acc-chart__nodata">Esperando datos del acelerómetro...</div>
  }
  } @else {
  <div class="acc-chart__disconnected">Conecta el dispositivo para ver el gráfico</div>
  }
</div>
---- src/app/features/acc-chart/acc-chart.component.ts ----
import { Component, inject, signal, effect, linkedSignal } from '@angular/core';
import { NgxChartsModule, ScaleType } from '@swimlane/ngx-charts';
import { CommonModule } from '@angular/common';
import { MovesenseService } from '../../core/services/movesense.service';
import { AccelerometerData } from '../../core/models/sensor-data.model';

// Chart data interfaces
interface ChartData {
    name: string;
    series: ChartSeriesData[];
}

interface ChartSeriesData {
    name: string | Date;
    value: number;
}

const MAX_ACC_DATA_POINTS = 100;

@Component({
    selector: 'app-acc-chart',
    templateUrl: './acc-chart.component.html',
    styleUrls: ['./acc-chart.component.scss'],
    standalone: true,
    imports: [NgxChartsModule, CommonModule]
})
export class AccChartComponent {
    private movesenseService = inject(MovesenseService);

    // Chart data signal
    readonly chartData = signal<ChartData[]>([
        { name: 'X', series: [] },
        { name: 'Y', series: [] },
        { name: 'Z', series: [] }
    ]);

    // Link connection status signal
    readonly isConnected = linkedSignal(this.movesenseService.isConnected);

    // Chart configuration
    readonly view: [number, number] = [700, 300];
    readonly legend = true;
    readonly showXAxisLabel = true;
    readonly showYAxisLabel = true;
    readonly xAxisLabel = 'Tiempo';
    readonly yAxisLabel = 'Aceleración (m/s²)';
    readonly timeline = true;
    readonly colorScheme = {
        name: 'accScheme',
        selectable: true,
        group: ScaleType.Ordinal,
        domain: ['#FF0000', '#00FF00', '#0000FF']
    };
    readonly autoScale = true;

    constructor() {
        // Effect to update chart when new accelerometer data arrives
        effect(() => {
            const newAccData = this.movesenseService.accelerometerData();
            if (newAccData && this.isConnected()) {
                this.updateChart(newAccData);
            }
        });

        // Effect to clear chart when disconnected
        effect(() => {
            if (!this.isConnected()) {
                this.chartData.set([
                    { name: 'X', series: [] },
                    { name: 'Y', series: [] },
                    { name: 'Z', series: [] }
                ]);
            }
        });
    }

    private updateChart(newData: AccelerometerData): void {
        this.chartData.update(currentChartData => {
            // Create a single new data point
            const timestamp = new Date(newData.timestamp);

            const newPointX: ChartSeriesData = { name: timestamp, value: newData.x };
            const newPointY: ChartSeriesData = { name: timestamp, value: newData.y };
            const newPointZ: ChartSeriesData = { name: timestamp, value: newData.z };

            // Add new points and limit history length
            const updatedSeriesX = [...currentChartData[0].series, newPointX].slice(-MAX_ACC_DATA_POINTS);
            const updatedSeriesY = [...currentChartData[1].series, newPointY].slice(-MAX_ACC_DATA_POINTS);
            const updatedSeriesZ = [...currentChartData[2].series, newPointZ].slice(-MAX_ACC_DATA_POINTS);

            return [
                { name: 'X', series: updatedSeriesX },
                { name: 'Y', series: updatedSeriesY },
                { name: 'Z', series: updatedSeriesZ }
            ];
        });
    }

    // Custom formatting for X-axis ticks
    xAxisTickFormatting(val: string | Date): string {
        if (val instanceof Date) {
            return val.toLocaleTimeString([], {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                fractionalSecondDigits: 3
            });
        }
        return String(val);
    }
}
---- src/app/features/memory-recording-list/memory-recording-list.component.scss ----
/* src/app/features/memory-recording-list/memory-recording-list.component.scss */
.memory-recording-list {
  padding: 1rem;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  background-color: #fff;
  width: 100%;

  &__title {
    margin-top: 0;
    margin-bottom: 1rem;
    font-size: 1.2rem;
    font-weight: 500;
    color: #333;
  }

  &__container {
    display: flex;
    gap: 1.5rem;

    @media (max-width: 768px) {
      flex-direction: column;
    }
  }

  &__list {
    flex: 1;
    max-width: 300px;
    border-right: 1px solid #eee;
    padding-right: 1rem;

    @media (max-width: 768px) {
      max-width: 100%;
      border-right: none;
      border-bottom: 1px solid #eee;
      padding-right: 0;
      padding-bottom: 1rem;
      margin-bottom: 1rem;
    }
  }

  &__item {
    padding: 0.8rem;
    border: 1px solid #eee;
    border-radius: 4px;
    margin-bottom: 0.6rem;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: background-color 0.2s ease;

    &:hover {
      background-color: #f9f9f9;
    }

    &--selected {
      background-color: #e3f2fd;
      border-color: #bbdefb;

      &:hover {
        background-color: #e3f2fd;
      }
    }
  }

  &__item-info {
    flex: 1;
  }

  &__item-name {
    font-weight: 500;
    margin-bottom: 0.3rem;
  }

  &__item-date {
    font-size: 0.8rem;
    color: #666;
  }

  &__item-duration {
    font-size: 0.8rem;
    color: #666;
  }

  &__delete-btn {
    background-color: transparent;
    color: #f44336;
    border: none;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    font-size: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    margin-left: 0.5rem;

    &:hover {
      background-color: rgba(244, 67, 54, 0.1);
    }
  }

  &__details {
    flex: 2;
    display: flex;
    flex-direction: column;
  }

  &__name-edit {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
  }

  &__name-input {
    flex: 1;
    padding: 0.5rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 0.9rem;
  }

  &__save-btn {
    padding: 0.5rem 1rem;
    background-color: #4caf50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;

    &:hover:not(:disabled) {
      background-color: #43a047;
    }

    &:disabled {
      background-color: #a5d6a7;
      cursor: not-allowed;
    }
  }

  &__viewer {
    flex: 1;
    min-height: 300px;
  }

  &__no-selection {
    flex: 2;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #9e9e9e;
    font-style: italic;
    min-height: 300px;
    border: 1px dashed #e0e0e0;
    border-radius: 4px;
  }

  &__empty {
    color: #9e9e9e;
    font-style: italic;
    padding: 2rem;
    text-align: center;
    border: 1px dashed #e0e0e0;
    border-radius: 4px;
  }
}

---- src/app/features/memory-recording-list/memory-recording-list.component.html ----
<!-- src/app/features/memory-recording-list/memory-recording-list.component.html -->
<div class="memory-recording-list">
    <h3 class="memory-recording-list__title">Grabaciones en Memoria</h3>

    @if (hasStoredRecordings()) {
    <div class="memory-recording-list__container">
        <div class="memory-recording-list__list">
            @for (recording of storedRecordings(); track recording.id) {
            <div class="memory-recording-list__item"
                [class.memory-recording-list__item--selected]="selectedRecordingId() === recording.id"
                (click)="selectRecording(recording.id)">
                <div class="memory-recording-list__item-info">
                    <div class="memory-recording-list__item-name">
                        {{ recording.name || 'Grabación sin nombre' }}
                    </div>
                    <div class="memory-recording-list__item-date">
                        {{ formatDateShort(recording.timestamp) }}
                    </div>
                    <div class="memory-recording-list__item-duration">
                        Duración: {{ formatDuration(recording.duration) }}
                    </div>
                </div>
                <button class="memory-recording-list__delete-btn" (click)="deleteRecording(recording.id, $event)"
                    aria-label="Eliminar grabación">
                    ✕
                </button>
            </div>
            }
        </div>

        @if (selectedRecordingId()) {
        <div class="memory-recording-list__details">
            <div class="memory-recording-list__name-edit">
                <input type="text" class="memory-recording-list__name-input" [value]="newRecordingName()"
                    (input)="updateNewName($event)" placeholder="Nombre de la grabación" />
                <button class="memory-recording-list__save-btn" (click)="saveRecordingName()"
                    [disabled]="!newRecordingName()">
                    Guardar
                </button>
            </div>

            <app-memory-recording-viewer [recordingId]="selectedRecordingId() || ''"
                class="memory-recording-list__viewer">
            </app-memory-recording-viewer>
        </div>
        } @else {
        <div class="memory-recording-list__no-selection">
            Selecciona una grabación para visualizarla
        </div>
        }
    </div>
    } @else {
    <div class="memory-recording-list__empty">
        No hay grabaciones guardadas. Utiliza la función de grabación en memoria.
    </div>
    }
    <div class="memory-recording-list__header">
        <h3 class="memory-recording-list__title">Grabaciones en Memoria</h3>
        <button class="memory-recording-list__clear-btn" (click)="clearAllRecordings()">
            Limpiar todas
        </button>
    </div>
</div>
---- src/app/features/memory-recording-list/memory-recording-list.component.ts ----
// src/app/features/memory-recording-list/memory-recording-list.component.ts
import { Component, inject, signal, linkedSignal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { FormsModule } from '@angular/forms';
import { StoredMemoryRecording } from '../../core/models/memory-recording.model';
import { MovesenseService } from '../../core/services/movesense.service';
import { MemoryRecordingViewerComponent } from '../memory-recording-viewer/memory-recording-viewer.component';
import { MemoryStorageService } from '../../core/services/memory-storage.service';

@Component({
  selector: 'app-memory-recording-list',
  standalone: true,
  imports: [CommonModule, FormsModule, MemoryRecordingViewerComponent],
  templateUrl: './memory-recording-list.component.html',
  styleUrl: './memory-recording-list.component.scss'
})
export class MemoryRecordingListComponent {
  private movesenseService = inject(MovesenseService);
  private memoryStorageService = inject(MemoryStorageService);

  // Link storage signals
  readonly storedRecordings = linkedSignal(this.movesenseService.storedMemoryRecordings);
  readonly hasStoredRecordings = linkedSignal(this.movesenseService.hasStoredMemoryRecordings);

  // Component state signals
  readonly selectedRecordingId = signal<string | null>(null);
  readonly newRecordingName = signal<string>('');

  selectRecording(id: string): void {
    if (this.selectedRecordingId() === id) {
      this.selectedRecordingId.set(null);
    } else {
      this.selectedRecordingId.set(id);

      // Set default name from selected recording
      const recording = this.movesenseService.getMemoryRecordingById(id);
      if (recording) {
        this.newRecordingName.set(recording.name || '');
      }
    }
  }

  saveRecordingName(): void {
    const id = this.selectedRecordingId();
    if (id && this.newRecordingName()) {
      this.movesenseService.renameMemoryRecording(this.newRecordingName(), id);
    }
  }

  deleteRecording(id: string, event: Event): void {
    event.stopPropagation(); // Prevent selection on delete

    if (confirm('¿Estás seguro de que deseas eliminar esta grabación?')) {
      this.movesenseService.deleteMemoryRecording(id);

      if (this.selectedRecordingId() === id) {
        this.selectedRecordingId.set(null);
      }
    }
  }

  formatDateShort(timestamp: number): string {
    const date = new Date(timestamp);
    return `${date.toLocaleDateString()} ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
  }

  formatDuration(seconds: number): string {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
  }

  updateNewName(event: Event): void {
    const input = event.target as HTMLInputElement;
    this.newRecordingName.set(input.value);
  }
  clearAllRecordings(): void {

    // Acceder al servicio de almacenamiento a través del servicio MoveSense
    this.memoryStorageService.clearAllRecordings();

  }
}
---- src/app/features/memory-recording-viewer/memory-recording-viewer.component.scss ----
/* src/app/features/memory-recording-viewer/memory-recording-viewer.component.scss */
.memory-viewer {
  width: 100%;

  &__info {
    margin-bottom: 1rem;
  }

  &__name {
    font-size: 1.1rem;
    font-weight: 500;
    margin-bottom: 0.5rem;
  }

  &__details {
    display: flex;
    gap: 1rem;
    font-size: 0.9rem;
    color: #666;
  }

  &__date,
  &__duration {
    &::after {
      content: "·";
      margin-left: 1rem;
      color: #bbb;
    }

    &:last-child::after {
      display: none;
    }
  }

  &__metric-selector {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
    flex-wrap: wrap;
  }

  &__metric-button {
    padding: 0.5rem 1rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    background-color: #f9f9f9;
    cursor: pointer;
    font-size: 0.9rem;
    transition: all 0.2s ease;

    &:hover {
      background-color: #f1f1f1;
    }

    &--active {
      background-color: #e3f2fd;
      border-color: #bbdefb;
      color: #1565c0;
    }
  }

  &__chart {
    border: 1px solid #eee;
    border-radius: 4px;
    padding: 1rem;
    min-height: 300px;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  &__chart-container {
    width: 100%;
    height: 300px;
  }

  &__no-data {
    color: #9e9e9e;
    font-style: italic;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 250px;
  }
}

---- src/app/features/memory-recording-viewer/memory-recording-viewer.component.html ----
<!-- src/app/features/memory-recording-viewer/memory-recording-viewer.component.html -->
<div class="memory-viewer">
    @if (recordingData()) {
    <div class="memory-viewer__info">
        <div class="memory-viewer__name">
            {{ recordingData()?.name || 'Grabación sin nombre' }}
        </div>
        <div class="memory-viewer__details">
            <span class="memory-viewer__date">
                {{ recordingData()?.timestamp | date:'medium' }}
            </span>
            <span class="memory-viewer__duration">
                Duración: {{ recordingData() ? recordingData()!.duration.toFixed(1) : 0 }}s
            </span>
        </div>
    </div>

    <div class="memory-viewer__metric-selector">
        @for (metric of availableMetrics(); track metric.id) {
        <button class="memory-viewer__metric-button"
            [class.memory-viewer__metric-button--active]="selectedMetric() === metric.id"
            (click)="selectMetric(metric.id)">
            {{ metric.name }}
        </button>
        }
    </div>

    <div class="memory-viewer__chart">
        @if (chartData().length > 0) {
        <ngx-charts-line-chart class="memory-viewer__chart-container" [view]="view" [scheme]="colorScheme"
            [results]="chartData()" [legend]="legend" [xAxis]="true" [yAxis]="true" [showXAxisLabel]="showXAxisLabel"
            [showYAxisLabel]="showYAxisLabel" [xAxisLabel]="xAxisLabel" [yAxisLabel]="yAxisLabel()"
            [timeline]="timeline" [autoScale]="autoScale" [xAxisTickFormatting]="xAxisTickFormatting">
        </ngx-charts-line-chart>
        } @else {
        <div class="memory-viewer__no-data">
            No hay datos disponibles para este tipo de sensor
        </div>
        }
    </div>
    } @else {
    <div class="memory-viewer__no-data">
        No se encontró la grabación solicitada
    </div>
    }
</div>
---- src/app/features/memory-recording-viewer/memory-recording-viewer.component.ts ----
// src/app/features/memory-recording-viewer/memory-recording-viewer.component.ts
import { Component, Input, inject, signal, computed, OnChanges, SimpleChanges } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NgxChartsModule, ScaleType } from '@swimlane/ngx-charts';
import { MovesenseService } from '../../core/services/movesense.service';
import { StoredMemoryRecording } from '../../core/models/memory-recording.model';

interface ChartData {
  name: string;
  series: ChartSeriesData[];
}

interface ChartSeriesData {
  name: string | Date;
  value: number;
}

@Component({
  selector: 'app-memory-recording-viewer',
  standalone: true,
  imports: [CommonModule, NgxChartsModule],
  templateUrl: './memory-recording-viewer.component.html',
  styleUrl: './memory-recording-viewer.component.scss'
})
export class MemoryRecordingViewerComponent implements OnChanges {
  @Input() recordingId = '';

  private movesenseService = inject(MovesenseService);

  // Component state signals
  readonly recordingData = signal<StoredMemoryRecording | null>(null);
  readonly chartData = signal<ChartData[]>([]);
  readonly selectedMetric = signal<string>('accelerometer');

  // Available metrics
  readonly availableMetrics = computed(() => {
    const recording = this.recordingData();
    if (!recording) return [];

    const metrics: { id: string, name: string }[] = [];

    if (recording.sensorData.accelerometer?.length) {
      metrics.push({ id: 'accelerometer', name: 'Acelerómetro' });
    }

    if (recording.sensorData.temperature?.length) {
      metrics.push({ id: 'temperature', name: 'Temperatura' });
    }

    if (recording.sensorData.heartRate?.length) {
      metrics.push({ id: 'heartRate', name: 'Ritmo Cardíaco' });
    }

    if (recording.sensorData.gyroscope?.length) {
      metrics.push({ id: 'gyroscope', name: 'Giroscopio' });
    }

    if (recording.sensorData.magnetometer?.length) {
      metrics.push({ id: 'magnetometer', name: 'Magnetómetro' });
    }

    if (recording.sensorData.ecg?.length) {
      metrics.push({ id: 'ecg', name: 'ECG' });
    }

    return metrics;
  });

  // Chart configuration
  readonly view: [number, number] = [700, 300];
  readonly legend = true;
  readonly showXAxisLabel = true;
  readonly showYAxisLabel = true;
  readonly xAxisLabel = 'Tiempo';
  readonly yAxisLabel = signal<string>('Valor');
  readonly timeline = true;
  readonly autoScale = true;
  readonly colorScheme = {
    name: 'memoryRecordingScheme',
    selectable: true,
    group: ScaleType.Ordinal,
    domain: ['#FF0000', '#00FF00', '#0000FF']
  };

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['recordingId']) {
      this.loadRecordingData();
    }
  }

  private loadRecordingData(): void {
    if (!this.recordingId) {
      this.recordingData.set(null);
      this.chartData.set([]);
      return;
    }

    const recording = this.movesenseService.getMemoryRecordingById(this.recordingId);

    if (!recording) {
      this.recordingData.set(null);
      this.chartData.set([]);
      return;
    }

    this.recordingData.set(recording);
    this.updateChartData();
  }

  selectMetric(metricId: string): void {
    this.selectedMetric.set(metricId);
    this.updateChartData();
  }

  private updateChartData(): void {
    const recording: any = this.recordingData();
    if (!recording) {
      this.chartData.set([]);
      return;
    }

    const metricId = this.selectedMetric();
    console.log(`Procesando datos para: ${metricId}`, recording);

    // Verificar si hay datos para el sensor seleccionado
    const sensorData = recording.sensorData[metricId];
    if (!sensorData || (Array.isArray(sensorData) && sensorData.length === 0)) {
      console.log(`No hay datos para ${metricId}`);
      this.chartData.set([]);
      return;
    }

    // Procesar datos según el tipo de sensor
    switch (metricId) {
      case 'accelerometer':
        this.generateAccelerometerChart(recording);
        this.yAxisLabel.set('Aceleración (m/s²)');
        break;
      case 'temperature':
        this.generateTemperatureChart(recording);
        this.yAxisLabel.set('Temperatura (°C)');
        break;
      case 'heartRate':
        this.generateHeartRateChart(recording);
        this.yAxisLabel.set('Ritmo Cardíaco (BPM)');
        break;
      case 'gyroscope':
        this.generateGyroscopeChart(recording);
        this.yAxisLabel.set('Velocidad Angular (°/s)');
        break;
      case 'magnetometer':
        this.generateMagnetometerChart(recording);
        this.yAxisLabel.set('Campo Magnético (µT)');
        break;
      case 'ecg':
        this.generateEcgChart(recording);
        this.yAxisLabel.set('ECG (mV)');
        break;
      default:
        this.chartData.set([]);
    }
  }

  private generateAccelerometerChart(recording: StoredMemoryRecording): void {
    const accData = recording.sensorData.accelerometer;
    if (!accData || accData.length === 0) {
      this.chartData.set([]);
      return;
    }

    const seriesX: ChartSeriesData[] = [];
    const seriesY: ChartSeriesData[] = [];
    const seriesZ: ChartSeriesData[] = [];

    accData.forEach(data => {
      const timestamp = new Date(data[0]);
      seriesX.push({ name: timestamp, value: data[1] });
      seriesY.push({ name: timestamp, value: data[2] });
      seriesZ.push({ name: timestamp, value: data[3] });
    });

    this.chartData.set([
      { name: 'X', series: seriesX },
      { name: 'Y', series: seriesY },
      { name: 'Z', series: seriesZ }
    ]);
  }

  private generateTemperatureChart(recording: StoredMemoryRecording): void {
    const tempData = recording.sensorData.temperature;
    if (!tempData || tempData.length === 0) {
      this.chartData.set([]);
      return;
    }

    const series: ChartSeriesData[] = [];
    const baseTime = recording.timestamp;

    tempData.forEach((value, index) => {
      const timestamp = new Date(baseTime + index * 1000);
      series.push({ name: timestamp, value });
    });

    this.chartData.set([{ name: 'Temperatura', series }]);
  }

  private generateHeartRateChart(recording: StoredMemoryRecording): void {
    const hrData = recording.sensorData.heartRate;
    if (!hrData || hrData.length === 0) {
      this.chartData.set([]);
      return;
    }

    const series: ChartSeriesData[] = [];
    const baseTime = recording.timestamp;

    hrData.forEach((value, index) => {
      const timestamp = new Date(baseTime + index * 1000);
      series.push({ name: timestamp, value });
    });

    this.chartData.set([{ name: 'Ritmo Cardíaco', series }]);
  }

  private generateGyroscopeChart(recording: StoredMemoryRecording): void {
    const gyroData = recording.sensorData.gyroscope;
    if (!gyroData || gyroData.length === 0) {
      this.chartData.set([]);
      return;
    }

    const seriesX: ChartSeriesData[] = [];
    const seriesY: ChartSeriesData[] = [];
    const seriesZ: ChartSeriesData[] = [];

    gyroData.forEach(data => {
      const timestamp = new Date(data[0]);
      seriesX.push({ name: timestamp, value: data[1] });
      seriesY.push({ name: timestamp, value: data[2] });
      seriesZ.push({ name: timestamp, value: data[3] });
    });

    this.chartData.set([
      { name: 'X', series: seriesX },
      { name: 'Y', series: seriesY },
      { name: 'Z', series: seriesZ }
    ]);
  }

  private generateMagnetometerChart(recording: StoredMemoryRecording): void {
    const magnData = recording.sensorData.magnetometer;
    if (!magnData || magnData.length === 0) {
      this.chartData.set([]);
      return;
    }

    const seriesX: ChartSeriesData[] = [];
    const seriesY: ChartSeriesData[] = [];
    const seriesZ: ChartSeriesData[] = [];

    magnData.forEach(data => {
      const timestamp = new Date(data[0]);
      seriesX.push({ name: timestamp, value: data[1] });
      seriesY.push({ name: timestamp, value: data[2] });
      seriesZ.push({ name: timestamp, value: data[3] });
    });

    this.chartData.set([
      { name: 'X', series: seriesX },
      { name: 'Y', series: seriesY },
      { name: 'Z', series: seriesZ }
    ]);
  }

  private generateEcgChart(recording: StoredMemoryRecording): void {
    const ecgData = recording.sensorData.ecg;
    if (!ecgData || ecgData.length === 0) {
      this.chartData.set([]);
      return;
    }

    const series: ChartSeriesData[] = [];
    const baseTime = recording.timestamp;
    const sampleRate = 128; // Hz para ECG
    const timePerSampleMs = 1000 / sampleRate;

    ecgData.forEach((value, index) => {
      const timestamp = new Date(baseTime + index * timePerSampleMs);
      series.push({ name: timestamp, value });
    });

    this.chartData.set([{ name: 'ECG', series }]);
  }

  // Axis formatting
  xAxisTickFormatting(val: string | Date): string {
    if (val instanceof Date) {
      return val.toLocaleTimeString([], {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 3
      });
    }
    return String(val);
  }
}
---- src/app/app.component.ts ----
import { CommonModule } from '@angular/common';
import { Component, inject, linkedSignal } from '@angular/core';
import { RouterOutlet } from '@angular/router';
import { MovesenseService } from './core/services/movesense.service';
import { AccChartComponent } from './features/acc-chart/acc-chart.component';
import { ConnectionComponent } from './features/connection/connection.component';
import { EcgChartComponent } from './features/ecg-chart/ecg-chart.component';
import { GyroDisplayComponent } from './features/gyro-display/gyro-display.component';
import { HrChartComponent } from './features/hr-chart/hr-chart.component';
import { MagnDisplayComponent } from './features/magn-display/magn-display.component';
import { MetricsDisplayComponent } from './features/metrics-display/metrics-display.component';
import { StoredEcgListComponent } from './features/stored-ecg-list/stored-ecg-list.component';
import { TemperatureDisplayComponent } from './features/temperature-display/temperature-display.component';
import { MemoryRecordingComponent } from './features/memory-recording/memory-recording.component';
import { MemoryRecordingListComponent } from './features/memory-recording-list/memory-recording-list.component';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [
    CommonModule,
    RouterOutlet,
    ConnectionComponent,
    TemperatureDisplayComponent,
    HrChartComponent,
    AccChartComponent,
    EcgChartComponent,
    MetricsDisplayComponent,
    GyroDisplayComponent,
    MagnDisplayComponent,
    StoredEcgListComponent,
    MemoryRecordingComponent,
    MemoryRecordingListComponent
  ],
  templateUrl: './app.component.html',
  styleUrl: './app.component.scss'
})
export class AppComponent {
  private movesenseService = inject(MovesenseService);

  // Link signals directly from the service
  readonly temperatureStatus = linkedSignal(this.movesenseService.temperatureStatus);
  readonly accelerometerStatus = linkedSignal(this.movesenseService.accelerometerStatus);
  readonly heartRateStatus = linkedSignal(this.movesenseService.heartRateStatus);
  readonly gyroscopeStatus = linkedSignal(this.movesenseService.gyroscopeStatus);
  readonly magnetometerStatus = linkedSignal(this.movesenseService.magnetometerStatus);
  readonly ecgStatus = linkedSignal(this.movesenseService.ecgStatus);
  readonly hasStoredEcgs = linkedSignal(this.movesenseService.hasStoredEcgs);

  readonly hasStoredMemoryRecordings = linkedSignal(this.movesenseService.hasStoredMemoryRecordings);
}
---- src/app/app.config.ts ----
import { ApplicationConfig, provideZoneChangeDetection } from '@angular/core';
import { provideRouter } from '@angular/router';
import { provideAnimations } from '@angular/platform-browser/animations'; // Import provideAnimations

import { routes } from './app.routes';

export const appConfig: ApplicationConfig = {
  providers: [
    provideZoneChangeDetection({ eventCoalescing: true }),
    provideRouter(routes),
    provideAnimations()
  ]
};

---- src/main.ts ----
import { bootstrapApplication } from '@angular/platform-browser';
import { appConfig } from './app/app.config';
import { AppComponent } from './app/app.component';

bootstrapApplication(AppComponent, appConfig)
  .catch((err) => console.error(err));

---- src/styles.scss ----
/* You can add global styles to this file, and also import other style files */

