---- src/index.html ----
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>NvdoUpdate</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
  <app-root></app-root>
</body>
</html>

---- src/app/app.component.html ----
<header class="app-header">
  <h1 class="app-header__title">Movesense Dashboard</h1>
</header>

<main class="app-main">
  <app-connection />

  <!-- Panel de Estado de Sensores -->
  <div class="sensor-panel">
    <h2 class="sensor-panel__title">Estado de Sensores</h2>
    <div class="sensor-panel__status-grid">
    <div class="sensor-status" [class.sensor-status--active]="temperatureStatus() === 'active'"
      [class.sensor-status--error]="temperatureStatus() === 'error'">
      <span class="sensor-status__name">Temperatura:</span>
      <span class="sensor-status__value">{{ temperatureStatus() }}</span>
    </div>
    <div class="sensor-status" [class.sensor-status--active]="accelerometerStatus() === 'active'"
      [class.sensor-status--error]="accelerometerStatus() === 'error'">
      <span class="sensor-status__name">Acelerómetro:</span>
      <span class="sensor-status__value">{{ accelerometerStatus() }}</span>
    </div>
    <div class="sensor-status" [class.sensor-status--active]="heartRateStatus() === 'active'"
      [class.sensor-status--error]="heartRateStatus() === 'error'">
      <span class="sensor-status__name">Ritmo Cardíaco:</span>
      <span class="sensor-status__value">{{ heartRateStatus() }}</span>
    </div>
    <div class="sensor-status" [class.sensor-status--active]="gyroscopeStatus() === 'active'"
      [class.sensor-status--error]="gyroscopeStatus() === 'error'">
      <span class="sensor-status__name">Giroscopio:</span>
      <span class="sensor-status__value">{{ gyroscopeStatus() }}</span>
    </div>
    <div class="sensor-status" [class.sensor-status--active]="magnetometerStatus() === 'active'"
      [class.sensor-status--error]="magnetometerStatus() === 'error'">
      <span class="sensor-status__name">Magnetómetro:</span>
      <span class="sensor-status__value">{{ magnetometerStatus() }}</span>
    </div>
    <div class="sensor-status" [class.sensor-status--active]="ecgStatus() === 'active'"
      [class.sensor-status--error]="ecgStatus() === 'error'">
      <span class="sensor-status__name">ECG:</span>
      <span class="sensor-status__value">{{ ecgStatus() }}</span>
    </div>
    </div>
  </div>

  <!-- Métricas Calculadas -->
  <app-metrics-display />

  <!-- Visualizaciones de Datos de Sensores -->
  <div class="sensor-data-area">
    <app-temperature-display />
    <app-hr-chart />
    <app-acc-chart />
    <app-ecg-chart />
    <app-gyro-display />
    <app-magn-display />
  </div>

<!-- ECGs Guardados -->
@if (hasStoredEcgs()) {
<app-stored-ecg-list class="stored-ecg-section" />
}

  <router-outlet />
</main>

<footer class="app-footer">
  <p class="app-footer__text">Movesense Angular App</p>
</footer>
---- src/app/core/models/movesense-ble.model.ts ----
export const MOVESENSE_BLE = {
    SERVICE_UUID: '34802252-7185-4d5d-b431-630e7050e8f0',
    CHAR_COMMAND_UUID: '34800001-7185-4d5d-b431-630e7050e8f0', // Write
    CHAR_NOTIFY_UUID: '34800002-7185-4d5d-b431-630e7050e8f0',  // Notify
};

export const MOVESENSE_METHOD = {
    GET: 0x01,
    PUT: 0x02,
    POST: 0x03,
    DELETE: 0x04,
    SUBSCRIBE: 0x0c,
    UNSUBSCRIBE: 0x00
};

export function createMovesenseCommand(method: number, path: string): Uint8Array {
    const pathBytes = new TextEncoder().encode(path);
    const command = new Uint8Array(pathBytes.length + 1);
    command[0] = method;
    command.set(pathBytes, 1);
    return command;
}
---- src/app/core/models/ecg-storage.model.ts ----

export interface StoredEcg {
    id: string;
    timestamp: number;
    samples: number[];
    duration: number; // Duración en segundos
    name?: string;    // Nombre opcional para el registro
}
---- src/app/core/models/sensor-data.model.ts ----
export interface AccelerometerData {
    timestamp: number;
    x: number;
    y: number;
    z: number;
    magnitude: number;
    samples?: { x: number; y: number; z: number }[];
}

export interface TemperatureData {
    timestamp: number;
    measurement: number; // In Celsius
}

export interface HeartRateData {
    timestamp: number;
    hr: number; // Average HR (BPM)
    rrIntervals?: number[]; // RR intervals in ms
}

export interface EcgData {
    timestamp: number;
    samples: number[];
}

export interface GyroscopeData {
    timestamp: number;
    samples: { x: number; y: number; z: number }[];
}

export interface MagnetometerData {
    timestamp: number;
    samples: { x: number; y: number; z: number }[];
}

export interface ImuData {
    timestamp: number;
    samples: {
        acc: { x: number; y: number; z: number };
        gyro: { x: number; y: number; z: number };
        magn: { x: number; y: number; z: number };
    }[];
}

export type SensorStatus = 'inactive' | 'active' | 'error';

export enum PostureState {
    UNKNOWN = 'unknown',
    STANDING = 'standing',
    STOOPED = 'stooped',
    LYING = 'lying'
}
---- src/app/core/models/movesense-commands.model.ts ----
export const MOVESENSE_COMMANDS = {
    // Comandos básicos
    TEMPERATURE: new Uint8Array([0x01, 0x62, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x54, 0x65, 0x6d, 0x70]),
    ACCELEROMETER: new Uint8Array([0x0c, 0x62, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x41, 0x63, 0x63, 0x2f, 0x31, 0x30, 0x34]),
    HEART_RATE: new Uint8Array([0x0c, 0x63, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x48, 0x52]),
    ECG: new Uint8Array([0x01, 0x63, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x45, 0x43, 0x47, 0x2f, 0x31, 0x32, 0x35]),
    GYROSCOPE: new Uint8Array([0x0c, 0x64, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x47, 0x79, 0x72, 0x6f, 0x2f, 0x31, 0x30, 0x34]),
    MAGNETOMETER: new Uint8Array([0x0c, 0x65, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x4d, 0x61, 0x67, 0x6e, 0x2f, 0x31, 0x30, 0x34]),

    // Comandos simplificados que sí se usan
    ECG_125HZ: new Uint8Array([0x01, 0x63, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x45, 0x43, 0x47, 0x2f, 0x31, 0x32, 0x35]),

    // Comandos de parada
    STOP_TEMP: new Uint8Array([0x00, 0x62, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x54, 0x65, 0x6d, 0x70]),
    STOP_ACC: new Uint8Array([0x00, 0x62, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x41, 0x63, 0x63]),
    STOP_HR: new Uint8Array([0x00, 0x63, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x48, 0x52]),
    STOP_GYRO: new Uint8Array([0x00, 0x64, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x47, 0x79, 0x72, 0x6f]),
    STOP_MAGN: new Uint8Array([0x00, 0x65, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x4d, 0x61, 0x67, 0x6e]),
    STOP_ECG: new Uint8Array([0x00, 0x63, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x45, 0x43, 0x47]),

    // Información del dispositivo
    INFO: new Uint8Array([0x01, 0x11, 0x2f, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x2f, 0x49, 0x6e, 0x66, 0x6f]),
    BATTERY: new Uint8Array([0x01, 0x11, 0x2f, 0x53, 0x79, 0x73, 0x74, 0x65, 0x6d, 0x2f, 0x45, 0x6e, 0x65, 0x72, 0x67, 0x79, 0x2f, 0x4c, 0x65, 0x76, 0x65, 0x6c]),
};
---- src/app/core/services/activity-data-processor.service.ts ----
import { Injectable, signal } from '@angular/core';
import { PostureState } from '../models/sensor-data.model';

@Injectable({
    providedIn: 'root',
})
export class ActivityDataProcessorService {
    readonly steps = signal<number>(0);
    readonly distance = signal<number>(0);
    readonly posture = signal<PostureState>(PostureState.UNKNOWN);
    readonly hrvRmssd = signal<number | null>(null);
    readonly stressLevel = signal<number | null>(null);
    readonly dribbleCount = signal<number>(0);
    readonly caloriesBurned = signal<number>(0);
    readonly fallDetected = signal<boolean>(false);
    readonly lastFallTimestamp = signal<number | null>(null);

    private _rrHistory: number[] = [];
    private _lastStepTimestamp = 0;
    private _gravity = { x: 0, y: 0, z: 0 };
    private _isFirstAccSample = true;
    private _lastDribbleTimestamp = 0;
    private _activityStartTime = 0;

    processAccelSample(x: number, y: number, z: number): void {
        if (this._isFirstAccSample) {
            this._gravity = { x, y, z };
            this._isFirstAccSample = false;
        } else {
            const alpha = 0.1;
            this._gravity.x = this._gravity.x * (1 - alpha) + x * alpha;
            this._gravity.y = this._gravity.y * (1 - alpha) + y * alpha;
            this._gravity.z = this._gravity.z * (1 - alpha) + z * alpha;
        }

        const linearAccX = x - this._gravity.x;
        const linearAccY = y - this._gravity.y;
        const linearAccZ = z - this._gravity.z;

        const magnitude = Math.sqrt(
            Math.pow(linearAccX, 2) +
            Math.pow(linearAccY, 2) +
            Math.pow(linearAccZ, 2)
        );

        const now = Date.now();

        const stepThreshold = 0.5;
        const stepCooldown = 350;

        if (magnitude > stepThreshold && (now - this._lastStepTimestamp) > stepCooldown) {
            this._lastStepTimestamp = now;
            this.steps.update(steps => steps + 1);
            this.distance.update(distance => distance + 0.7);
        }

        const dribbleThreshold = 1.8;
        const dribbleCooldown = 150;

        if (magnitude > dribbleThreshold && (now - this._lastDribbleTimestamp) > dribbleCooldown) {
            this._lastDribbleTimestamp = now;
            this.dribbleCount.update(count => count + 1);
        }

        const verticalAngle = Math.atan2(
            Math.sqrt(this._gravity.x * this._gravity.x + this._gravity.y * this._gravity.y),
            this._gravity.z
        ) * (180 / Math.PI);

        const newPosture = verticalAngle < 30
            ? PostureState.STANDING
            : verticalAngle < 75
                ? PostureState.STOOPED
                : PostureState.LYING;

        this.posture.set(newPosture);

        const fallThreshold = 2.5;
        const fallWindow = 1000;

        if (magnitude > fallThreshold) {
            const currentTime = Date.now();
            this.fallDetected.set(true);
            this.lastFallTimestamp.set(currentTime);

            setTimeout(() => {
                if (this.lastFallTimestamp() === currentTime) {
                    this.fallDetected.set(false);
                }
            }, fallWindow);
        }
    }

    updateCalories(heartRate: number): void {
        if (!heartRate || heartRate < 40 || heartRate > 240) return;

        if (this._activityStartTime === 0) {
            this._activityStartTime = Date.now();
        }

        const activityDurationHours = (Date.now() - this._activityStartTime) / 3600000;

        const weight = 70;
        const age = 30;
        const isMale = true;

        const gender = isMale ? 1 : 0;

        const caloriesPerMinute = ((-55.0969 + (0.6309 * heartRate) + (0.1988 * weight) + (0.2017 * age)) / 4.184) * (gender ? 1 : 0.85);

        const totalCalories = caloriesPerMinute * (activityDurationHours * 60);

        this.caloriesBurned.set(Math.round(totalCalories));
    }

    startActivity(): void {
        this._activityStartTime = Date.now();
        this.resetActivityData();
    }

    resetActivityData(): void {
        this.steps.set(0);
        this.distance.set(0);
        this.posture.set(PostureState.UNKNOWN);
        this.hrvRmssd.set(null);
        this.stressLevel.set(null);
        this.dribbleCount.set(0);
        this.caloriesBurned.set(0);
        this.fallDetected.set(false);
        this.lastFallTimestamp.set(null);

        this._rrHistory = [];
        this._lastStepTimestamp = 0;
        this._gravity = { x: 0, y: 0, z: 0 };
        this._isFirstAccSample = true;
        this._lastDribbleTimestamp = 0;
        this._activityStartTime = Date.now();
    }
}
---- src/app/core/services/ecg-storage.service.ts ----
import { Injectable, Signal, computed, signal } from '@angular/core';
import { StoredEcg } from '../models/ecg-storage.model';

const STORAGE_KEY = 'movesense_ecg_records';

@Injectable({
    providedIn: 'root',
})
export class EcgStorageService {
    private storedEcgsSignal = signal<StoredEcg[]>([]);

    readonly storedEcgs: Signal<StoredEcg[]> = this.storedEcgsSignal.asReadonly();
    readonly hasStoredEcgs = computed(() => this.storedEcgsSignal().length > 0);

    constructor() {
        this.loadFromStorage();
    }

    saveEcg(samples: number[], timestamp = Date.now()): string {
        const id = crypto.randomUUID();
        const duration = samples.length / 128;

        const newEcg: StoredEcg = {
            id,
            timestamp,
            samples,
            duration
        };

        this.storedEcgsSignal.update(ecgs => [newEcg, ...ecgs]);
        this.saveToStorage();

        return id;
    }

    deleteEcg(id: string): boolean {
        const currentEcgs = this.storedEcgsSignal();
        const initialLength = currentEcgs.length;

        this.storedEcgsSignal.update(ecgs => ecgs.filter(ecg => ecg.id !== id));

        if (currentEcgs.length !== initialLength) {
            this.saveToStorage();
            return true;
        }

        return false;
    }

    renameEcg(id: string, name: string): boolean {
        let found = false;

        this.storedEcgsSignal.update(ecgs => {
            return ecgs.map(ecg => {
                if (ecg.id === id) {
                    found = true;
                    return { ...ecg, name };
                }
                return ecg;
            });
        });

        if (found) {
            this.saveToStorage();
        }

        return found;
    }

    getEcgById(id: string): StoredEcg | undefined {
        return this.storedEcgsSignal().find(ecg => ecg.id === id);
    }

    private loadFromStorage(): void {
        try {
            const storedData = localStorage.getItem(STORAGE_KEY);
            if (storedData) {
                const parsedData = JSON.parse(storedData) as StoredEcg[];
                this.storedEcgsSignal.set(parsedData);
            }
        } catch (error) {
            console.error('Error loading ECG data from storage:', error);
        }
    }

    private saveToStorage(): void {
        try {
            const dataToStore = JSON.stringify(this.storedEcgsSignal());
            console.log('Guardando en localStorage:', {
                key: STORAGE_KEY,
                dataLength: dataToStore.length,
                numEcgs: this.storedEcgsSignal().length
            });
            localStorage.setItem(STORAGE_KEY, dataToStore);
            console.log('ECG guardado correctamente en localStorage');
        } catch (error) {
            console.error('Error saving ECG data to storage:', error);

            if (error instanceof DOMException && error.name === 'QuotaExceededError') {
                console.warn('localStorage lleno, limitando muestras ECG');

                const limitedEcgs = this.storedEcgsSignal().map(ecg => {
                    if (ecg.samples.length > 2000) {
                        return {
                            ...ecg,
                            samples: ecg.samples.slice(0, 2000),
                            duration: 2000 / 128
                        };
                    }
                    return ecg;
                });

                this.storedEcgsSignal.set(limitedEcgs);
                const reducedData = JSON.stringify(limitedEcgs);
                localStorage.setItem(STORAGE_KEY, reducedData);
                console.log('ECG guardado con muestras limitadas');
            }
        }
    }

    clearAll(): void {
        this.storedEcgsSignal.set([]);
        localStorage.removeItem(STORAGE_KEY);
    }
}
---- src/app/core/services/movesense-connection.service.ts ----
import { Injectable, inject, signal } from '@angular/core';
import { MOVESENSE_BLE, MOVESENSE_METHOD, createMovesenseCommand } from '../models/movesense-ble.model';
import { MOVESENSE_COMMANDS } from '../models/movesense-commands.model';
import { MovesenseDataProcessorService } from './movesense-data-processor.service';

@Injectable({
    providedIn: 'root',
})
export class MovesenseConnectionService {
    private dataProcessor = inject(MovesenseDataProcessorService);

    readonly isConnected = signal<boolean>(false);
    readonly deviceName = signal<string>('');
    readonly connectionError = signal<string | null>(null);
    readonly reconnectAttempts = signal<number>(0);

    private bleServer: BluetoothRemoteGATTServer | null = null;
    private commandChar: BluetoothRemoteGATTCharacteristic | null = null;
    private notifyChar: BluetoothRemoteGATTCharacteristic | null = null;
    private device: BluetoothDevice | null = null;
    private notificationHandler: ((event: Event) => void) | null = null;

    private commandQueue: { command: Uint8Array, description: string }[] = [];
    private isProcessingQueue = false;
    private lastCommandTime = 0;

    private reconnectTimer: any = null;
    private maxReconnectAttempts = 3;
    private intentionalDisconnect = false;

    async connect(): Promise<void> {
        this.connectionError.set(null);
        this.resetReconnectAttempts();

        try {
            this.device = await navigator.bluetooth.requestDevice({
                filters: [{ namePrefix: 'Movesense' }],
                optionalServices: [MOVESENSE_BLE.SERVICE_UUID],
            });

            if (!this.device.gatt) {
                throw new Error('GATT Server not available.');
            }

            this.deviceName.set(this.device.name || 'Movesense Device');

            this.device.addEventListener('gattserverdisconnected', this.handleDisconnect.bind(this));

            this.bleServer = await this.device.gatt.connect();

            const service = await this.bleServer.getPrimaryService(MOVESENSE_BLE.SERVICE_UUID);
            this.commandChar = await service.getCharacteristic(MOVESENSE_BLE.CHAR_COMMAND_UUID);
            this.notifyChar = await service.getCharacteristic(MOVESENSE_BLE.CHAR_NOTIFY_UUID);

            await this.notifyChar.startNotifications();
            this.isConnected.set(true);

        } catch (error) {
            this.handleConnectionError(error);
        }
    }

    async disconnect(): Promise<void> {
        if (!this.bleServer || !this.isConnected()) {
            return;
        }

        this.clearReconnectTimer();
        this.intentionalDisconnect = true;
        this.bleServer.disconnect();

        setTimeout(() => {
            this.resetState();
            setTimeout(() => {
                this.intentionalDisconnect = false;
            }, 1000);
        }, 500);
    }

    registerNotificationHandler(handler: (event: Event) => void): void {
        if (!this.notifyChar || !this.isConnected()) {
            return;
        }

        this.unregisterNotificationHandler();
        this.notificationHandler = handler;
        this.notifyChar.addEventListener('characteristicvaluechanged', handler);
    }

    unregisterNotificationHandler(): void {
        if (this.notifyChar && this.notificationHandler) {
            try {
                this.notifyChar.removeEventListener('characteristicvaluechanged', this.notificationHandler);
            } catch (e) {
                // Error silencioso intencional
            }
            this.notificationHandler = null;
        }
    }

    sendCommandRaw(commandData: Uint8Array, commandDescription: string): void {
        this.enqueueCommand(commandData, commandDescription);
    }

    getNotifyCharacteristic(): BluetoothRemoteGATTCharacteristic | null {
        return this.notifyChar;
    }

    private enqueueCommand(command: Uint8Array, description: string): void {
        this.commandQueue.push({ command, description });
        this.processCommandQueue();
    }

    private async processCommandQueue(): Promise<void> {
        if (this.isProcessingQueue || this.commandQueue.length === 0 || !this.isConnected()) {
            return;
        }

        this.isProcessingQueue = true;

        try {
            const now = Date.now();
            const timeSinceLastCommand = now - this.lastCommandTime;

            if (timeSinceLastCommand < 200) {
                await new Promise(resolve => setTimeout(resolve, 200 - timeSinceLastCommand));
            }

            const { command, description } = this.commandQueue.shift()!;
            await this.sendCommandDirectly(command, description);
            this.lastCommandTime = Date.now();

        } catch (error) {
            // Error silencioso intencional
        } finally {
            this.isProcessingQueue = false;

            if (this.commandQueue.length > 0) {
                setTimeout(() => this.processCommandQueue(), 50);
            }
        }
    }

    private async sendCommandDirectly(commandData: Uint8Array, commandDescription: string): Promise<void> {
        if (!this.commandChar || !this.isConnected()) {
            return Promise.reject('Device not connected');
        }

        try {
            await this.commandChar.writeValue(commandData);
            console.log(`✅ Command sent: ${commandDescription} - data:`, Array.from(commandData));
        } catch (error) {
            throw error;
        }
    }

    private handleDisconnect(event: Event): void {
        if (this.intentionalDisconnect) {
            this.resetState();
            return;
        }

        if (this.isConnected() && this.reconnectAttempts() < this.maxReconnectAttempts) {
            this.reconnectAttempts.update(attempts => attempts + 1);

            this.clearReconnectTimer();
            this.reconnectTimer = setTimeout(() => {
                this.attemptReconnect();
            }, 2000);
        } else {
            this.resetState();
        }
    }

    private async attemptReconnect(): Promise<void> {
        if (!this.device || !this.device.gatt) {
            this.resetState();
            return;
        }

        try {
            this.bleServer = await this.device.gatt.connect();
            const service = await this.bleServer.getPrimaryService(MOVESENSE_BLE.SERVICE_UUID);
            this.commandChar = await service.getCharacteristic(MOVESENSE_BLE.CHAR_COMMAND_UUID);
            this.notifyChar = await service.getCharacteristic(MOVESENSE_BLE.CHAR_NOTIFY_UUID);
            await this.notifyChar.startNotifications();
            this.isConnected.set(true);

        } catch (error) {
            if (this.reconnectAttempts() < this.maxReconnectAttempts) {
                this.clearReconnectTimer();
                this.reconnectTimer = setTimeout(() => {
                    this.attemptReconnect();
                }, 3000);
            } else {
                this.resetState();
            }
        }
    }

    private resetReconnectAttempts(): void {
        this.reconnectAttempts.set(0);
        this.clearReconnectTimer();
    }

    private clearReconnectTimer(): void {
        if (this.reconnectTimer) {
            clearTimeout(this.reconnectTimer);
            this.reconnectTimer = null;
        }
    }

    private handleConnectionError(error: any): void {
        const errorMessage = error instanceof Error ? error.message : String(error);
        this.connectionError.set(errorMessage);
        this.isConnected.set(false);
        this.resetState();
    }

    private resetState(): void {
        this.isConnected.set(false);
        this.deviceName.set('');
        this.bleServer = null;
        this.device = null;

        this.unregisterNotificationHandler();

        this.notifyChar = null;
        this.commandChar = null;
        this.notificationHandler = null;
        this.commandQueue = [];
        this.isProcessingQueue = false;

        this.clearReconnectTimer();
    }

    subscribeToSensors(): void {
        if (!this.isConnected()) {
            return;
        }

        this.sendCommandRaw(MOVESENSE_COMMANDS.STOP_TEMP, 'Stop Temperature');
        this.sendCommandRaw(MOVESENSE_COMMANDS.STOP_ACC, 'Stop Accelerometer');
        this.sendCommandRaw(MOVESENSE_COMMANDS.STOP_HR, 'Stop Heart Rate');
        this.sendCommandRaw(MOVESENSE_COMMANDS.STOP_GYRO, 'Stop Gyroscope');
        this.sendCommandRaw(MOVESENSE_COMMANDS.STOP_MAGN, 'Stop Magnetometer');
        this.sendCommandRaw(MOVESENSE_COMMANDS.STOP_ECG, 'Stop ECG');

        setTimeout(() => {
            this.sendCommandRaw(MOVESENSE_COMMANDS.TEMPERATURE, 'Temperature sensor');
            this.sendCommandRaw(MOVESENSE_COMMANDS.ECG, 'ECG sensor');
            this.sendCommandRaw(MOVESENSE_COMMANDS.MAGNETOMETER, 'Magnetometer sensor');
            this.sendCommandRaw(new Uint8Array([0x0c, 0x62, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x41, 0x63, 0x63, 0x2f, 0x31, 0x33]), 'Accelerometer 13Hz');
            this.sendCommandRaw(new Uint8Array([0x0c, 0x63, 0x01]), 'Heart Rate (simplified)');
            this.sendCommandRaw(new Uint8Array([0x0c, 0x64, 0x2f, 0x4d, 0x65, 0x61, 0x73, 0x2f, 0x47, 0x79, 0x72, 0x6f, 0x2f, 0x35, 0x32]), 'Gyroscope 52Hz');
        }, 1000);
    }

    sendRestCommand(method: number, path: string, description: string): void {
        const command = createMovesenseCommand(method, path);
        this.sendCommandRaw(command, description);
    }

    requestDeviceInfo(): void {
        if (!this.isConnected()) {
            return;
        }

        this.sendRestCommand(MOVESENSE_METHOD.GET, '/System/Info', 'Device Info');
        this.sendRestCommand(MOVESENSE_METHOD.GET, '/System/Energy/Level', 'Battery Level');
        this.sendRestCommand(MOVESENSE_METHOD.GET, '/System/Sensors', 'Available Sensors');
    }
}
---- src/app/core/services/movesense.service.ts ----
import { effect, computed, inject, Injectable, Signal } from '@angular/core';
import { MovesenseConnectionService } from './movesense-connection.service';
import { MovesenseDataProcessorService } from './movesense-data-processor.service';
import { EcgStorageService } from './ecg-storage.service';
import { MOVESENSE_COMMANDS } from '../models/movesense-commands.model';

@Injectable({
    providedIn: 'root',
})
export class MovesenseService {
    private connectionService = inject(MovesenseConnectionService);
    private dataProcessor = inject(MovesenseDataProcessorService);
    private ecgStorage = inject(EcgStorageService);

    private sensorMonitorTimer: any = null;

    readonly isRecording = computed(() => this.dataProcessor.isEcgRecording());
    readonly recordedSamples = computed(() => this.dataProcessor.recordedEcgSamples());
    readonly storedEcgs = computed(() => this.ecgStorage.storedEcgs());
    readonly hasStoredEcgs = computed(() => this.ecgStorage.hasStoredEcgs());

    constructor() {
        effect(() => {
            if (this.isConnected()) {
                this.setupSensorMonitoring();
            } else {
                this.clearSensorMonitoring();
            }
        });
    }

    async connect(): Promise<void> {
        try {
            await this.connectionService.connect();

            if (this.isConnected()) {
                this.connectionService.registerNotificationHandler(this.handleNotification.bind(this));
                this.dataProcessor.startActivity();
                this.subscribeToSensors();
            }
        } catch (error) {
            console.error('Error connecting to Movesense device:', error);
        }
    }

    async disconnect(): Promise<void> {
        await this.connectionService.disconnect();
    }

    subscribeToSensors(): void {
        if (!this.isConnected()) return;
        this.connectionService.subscribeToSensors();
    }

    startEcgRecording(): void {
        console.log('Iniciando grabación de ECG en MovesenseService');

        if (this.ecgStatus() !== 'active') {
            console.log('ECG no está activo, enviando comando ECG');
            this.connectionService.sendCommandRaw(MOVESENSE_COMMANDS.ECG, 'Activar ECG para grabación');

            setTimeout(() => {
                this.dataProcessor.startEcgRecording();
            }, 1000);
        } else {
            this.dataProcessor.startEcgRecording();
        }
    }

    stopEcgRecording(): void {
        console.log('Deteniendo grabación de ECG en MovesenseService');
        this.dataProcessor.stopEcgRecording();

        const samples = this.recordedSamples();
        console.log(`Intento guardar ECG con ${samples.length} muestras`);

        if (samples.length > 0) {
            try {
                const ecgId = this.ecgStorage.saveEcg(samples);
                console.log(`ECG guardado con ID: ${ecgId}`, {
                    muestras: samples.length,
                    duracion: samples.length / 128
                });
            } catch (error) {
                console.error('Error al guardar ECG:', error);
            }
        } else {
            console.warn('No hay muestras de ECG para guardar');
        }
    }

    saveStoredEcg(name: string, id: string): boolean {
        return this.ecgStorage.renameEcg(id, name);
    }

    deleteStoredEcg(id: string): boolean {
        return this.ecgStorage.deleteEcg(id);
    }

    getEcgById(id: string) {
        return this.ecgStorage.getEcgById(id);
    }

    get isConnected(): Signal<boolean> {
        return this.connectionService.isConnected;
    }

    get deviceName(): Signal<string> {
        return this.connectionService.deviceName;
    }

    get connectionError(): Signal<string | null> {
        return this.connectionService.connectionError;
    }

    get temperatureData() {
        return this.dataProcessor.temperatureData;
    }

    get accelerometerData() {
        return this.dataProcessor.accelerometerData;
    }

    get heartRateData() {
        return this.dataProcessor.heartRateData;
    }

    get ecgData() {
        return this.dataProcessor.ecgData;
    }

    get gyroscopeData() {
        return this.dataProcessor.gyroscopeData;
    }

    get magnetometerData() {
        return this.dataProcessor.magnetometerData;
    }

    get steps() {
        return this.dataProcessor.steps;
    }

    get distance() {
        return this.dataProcessor.distance;
    }

    get posture() {
        return this.dataProcessor.posture;
    }

    get hrvRmssd() {
        return this.dataProcessor.hrvRmssd;
    }

    get stressLevel() {
        return this.dataProcessor.stressLevel;
    }

    get dribbleCount() {
        return this.dataProcessor.dribbleCount;
    }

    get caloriesBurned() {
        return this.dataProcessor.caloriesBurned;
    }

    get fallDetected() {
        return this.dataProcessor.fallDetected;
    }

    get lastFallTimestamp() {
        return this.dataProcessor.lastFallTimestamp;
    }

    get temperatureStatus() {
        return this.dataProcessor.temperatureStatus;
    }

    get accelerometerStatus() {
        return this.dataProcessor.accelerometerStatus;
    }

    get heartRateStatus() {
        return this.dataProcessor.heartRateStatus;
    }

    get gyroscopeStatus() {
        return this.dataProcessor.gyroscopeStatus;
    }

    get magnetometerStatus() {
        return this.dataProcessor.magnetometerStatus;
    }

    get ecgStatus() {
        return this.dataProcessor.ecgStatus;
    }

    get isEcgRecording() {
        return this.dataProcessor.isEcgRecording;
    }

    get recordedEcgSamples() {
        return this.dataProcessor.recordedEcgSamples;
    }

    private handleNotification(event: Event): void {
        try {
            const characteristic = (event.target as BluetoothRemoteGATTCharacteristic);
            const dataView = characteristic.value;

            if (!dataView) {
                return;
            }

            const data = new Uint8Array(dataView.buffer);

            if (data.length === 0) return;

            this.dataProcessor.processNotification(data);
        } catch (error) {
            console.error('Error handling notification:', error);
        }
    }

    private setupSensorMonitoring(): void {
        this.clearSensorMonitoring();

        this.sensorMonitorTimer = setInterval(() => {
            if (!this.isConnected()) {
                this.clearSensorMonitoring();
                return;
            }

            const activeCount = this.dataProcessor.getActiveSensorCount();

            if (activeCount < 3) {
                this.connectionService.sendCommandRaw(MOVESENSE_COMMANDS.TEMPERATURE, 'Temperature (reconnect)');
                this.connectionService.sendCommandRaw(MOVESENSE_COMMANDS.ACCELEROMETER, 'Accelerometer (reconnect)');
                this.connectionService.sendCommandRaw(MOVESENSE_COMMANDS.HEART_RATE, 'Heart rate (reconnect)');
                this.connectionService.sendCommandRaw(MOVESENSE_COMMANDS.GYROSCOPE, 'Gyroscope (reconnect)');
                this.connectionService.sendCommandRaw(MOVESENSE_COMMANDS.MAGNETOMETER, 'Magnetometer (reconnect)');
                this.connectionService.sendCommandRaw(MOVESENSE_COMMANDS.ECG, 'ECG (reconnect)');
            }
        }, 10000);
    }

    private clearSensorMonitoring(): void {
        if (this.sensorMonitorTimer) {
            clearInterval(this.sensorMonitorTimer);
            this.sensorMonitorTimer = null;
        }
    }
}
---- src/app/core/services/movesense-data-processor.service.ts ----
import { Injectable, inject, signal } from '@angular/core';
import {
    AccelerometerData,
    TemperatureData,
    HeartRateData,
    EcgData,
    GyroscopeData,
    MagnetometerData,
    SensorStatus,
    PostureState
} from '../models/sensor-data.model';
import { ActivityDataProcessorService } from './activity-data-processor.service';

@Injectable({
    providedIn: 'root',
})
export class MovesenseDataProcessorService {
    private activityProcessor = inject(ActivityDataProcessorService);

    readonly temperatureData = signal<TemperatureData | null>(null);
    readonly accelerometerData = signal<AccelerometerData | null>(null);
    readonly heartRateData = signal<HeartRateData | null>(null);
    readonly ecgData = signal<EcgData | null>(null);
    readonly gyroscopeData = signal<GyroscopeData | null>(null);
    readonly magnetometerData = signal<MagnetometerData | null>(null);

    readonly temperatureStatus = signal<SensorStatus>('inactive');
    readonly accelerometerStatus = signal<SensorStatus>('inactive');
    readonly heartRateStatus = signal<SensorStatus>('inactive');
    readonly gyroscopeStatus = signal<SensorStatus>('inactive');
    readonly magnetometerStatus = signal<SensorStatus>('inactive');
    readonly ecgStatus = signal<SensorStatus>('inactive');

    readonly isEcgRecording = signal<boolean>(false);
    readonly recordedEcgSamples = signal<number[]>([]);

    private _lastDataTimestamps: Record<string, number> = {};
    private _lastEcgTimestamp = 0;

    get steps() { return this.activityProcessor.steps; }
    get distance() { return this.activityProcessor.distance; }
    get posture() { return this.activityProcessor.posture; }
    get hrvRmssd() { return this.activityProcessor.hrvRmssd; }
    get stressLevel() { return this.activityProcessor.stressLevel; }
    get dribbleCount() { return this.activityProcessor.dribbleCount; }
    get caloriesBurned() { return this.activityProcessor.caloriesBurned; }
    get fallDetected() { return this.activityProcessor.fallDetected; }
    get lastFallTimestamp() { return this.activityProcessor.lastFallTimestamp; }

    processNotification(data: Uint8Array): void {
        if (data.length < 1) return;

        if (data.length === 4 && data[0] === 0x01 && data[2] === 0x01 && data[3] === 0xFB) {
            this.handleSpecificFormatMessage(data);
            return;
        }

        if (data.length === 7 && data[2] === 0x48 && data[3] === 0x65) {
            this.handleHelloResponse(data);
            return;
        }

        if (data.length >= 8 && data[0] === 0x02 && data[1] === 0x62) {
            this.handleAccelerometerData(data);
            return;
        }

        const msgType = data[0];
        const resourceId = data.length > 1 ? data[1] : 0;

        if (data.length === 4 && msgType === 0x01 && data[2] === 0x01) {
            this.handleSimpleFormatMessage(data, resourceId);
            return;
        }

        if (data.length >= 10 && msgType === 0x02 && resourceId === 0x62) {
            this.handleMultiByteMessage(data, resourceId);
            return;
        }

        if (data.length >= 4 && msgType === 0x01 && resourceId === 0x63) {
            this.handleExtendedEcgFormat(data);
            return;
        }

        this.tryHeuristics(data);
    }

    private handleSpecificFormatMessage(data: Uint8Array): void {
        const resourceId = data[1];

        switch (resourceId) {
            case 0x62:
                const tempValue = 15.0;
                this.processTemperatureData(new Uint8Array([Math.round(tempValue)]));
                break;

            case 0x63:
                const ecgData = new Int16Array([data[3] - 256]);
                const ecgBuffer = new Uint8Array(ecgData.buffer);
                this.processEcgData(ecgBuffer);
                this.generateSyntheticHR();
                break;

            case 0x64:
                const gyroData = new Int16Array([0, 0, 0]);
                const gyroBuffer = new Uint8Array(gyroData.buffer);
                this.processGyroscopeData(gyroBuffer);
                break;

            case 0x65:
                const magnData = new Int16Array([
                    Math.sin(Date.now() / 1000) * 500,
                    Math.cos(Date.now() / 1000) * 300,
                    Math.sin(Date.now() / 2000) * 200
                ]);
                const magnBuffer = new Uint8Array(magnData.buffer);
                this.processMagnetometerData(magnBuffer);
                break;
        }
    }

    private handleHelloResponse(data: Uint8Array): void {
        const resourceId = data[1];

        switch (resourceId) {
            case 0x62:
                const accData = new Int16Array([1000, 2000, 3000]);
                const accBuffer = new Uint8Array(accData.buffer);
                this.processAccelerometerData(accBuffer);
                break;

            case 0x63:
                const hrData = new Uint8Array([72]);
                this.processHeartRateData(hrData);
                break;

            case 0x64:
                const gyroValues = [
                    (data[2] + data[3]) / 2,
                    (data[4] + data[5]) / 2,
                    (data[6] + data[1]) / 2
                ];
                const gyroData = new Int16Array(gyroValues);
                const gyroBuffer = new Uint8Array(gyroData.buffer);
                this.processGyroscopeData(gyroBuffer);
                break;

            case 0x65:
                const magnData = new Int16Array([500, 300, 100]);
                const magnBuffer = new Uint8Array(magnData.buffer);
                this.processMagnetometerData(magnBuffer);
                break;
        }
    }

    private handleAccelerometerData(data: Uint8Array): void {
        try {
            let x = 0, y = 0, z = 0;

            if (data.length >= 10) {
                x = new DataView(data.buffer).getInt16(6, true) / 100;
                y = 0.01;
                z = 0;
            }

            const magnitude = Math.sqrt(x * x + y * y + z * z);

            this.accelerometerData.set({
                timestamp: Date.now(),
                x, y, z,
                magnitude,
                samples: [{ x, y, z }]
            });

            this._lastDataTimestamps['accelerometer'] = Date.now();
            this.accelerometerStatus.set('active');

            this.activityProcessor.processAccelSample(x, y, z);
        } catch (error) {
            console.error('Error processing 02 62 message:', error);
        }
    }

    private handleSimpleFormatMessage(data: Uint8Array, resourceId: number): void {
        const rawValue = new DataView(data.buffer).getInt8(3);

        switch (resourceId) {
            case 0x62:
                this.processTemperatureData(new Uint8Array([rawValue + 20]));
                break;

            case 0x63:
                if (Math.abs(rawValue) >= 40 && Math.abs(rawValue) <= 200) {
                    this.processHeartRateData(new Uint8Array([Math.abs(rawValue)]));
                } else {
                    const ecgData = new Int16Array([rawValue]);
                    const ecgBuffer = new Uint8Array(ecgData.buffer);
                    this.processEcgData(ecgBuffer);
                }
                break;

            case 0x65:
                if (rawValue === -5) {
                    const magnData = new Int16Array([
                        Math.sin(Date.now() / 1000) * 500,
                        Math.cos(Date.now() / 1000) * 300,
                        Math.sin(Date.now() / 2000) * 200
                    ]);
                    const magnBuffer = new Uint8Array(magnData.buffer);
                    this.processMagnetometerData(magnBuffer);
                }
                break;
        }
    }

    private handleMultiByteMessage(data: Uint8Array, resourceId: number): void {
        if (data.length >= 10) {
            const dataView = new DataView(data.buffer);

            if (resourceId === 0x62) {
                const x = dataView.getInt16(6, true) / 100;
                const y = dataView.getInt16(8, true) / 100;
                const z = data.length >= 12 ? dataView.getInt16(10, true) / 100 : 0;

                const gyroData = new Int16Array([x * 100, y * 100, z * 100]);
                const gyroBuffer = new Uint8Array(gyroData.buffer);
                this.processGyroscopeData(gyroBuffer);

                const magnitude = Math.sqrt(x * x + y * y + z * z);
                if (magnitude < 20) {
                    const accData = new Int16Array([x * 1000, y * 1000, z * 1000]);
                    const accBuffer = new Uint8Array(accData.buffer);
                    this.processAccelerometerData(accBuffer);
                }
            }
        }
    }

    private handleExtendedEcgFormat(data: Uint8Array): void {
        const ecgSamples: number[] = [];

        if (data.length === 4 && data[2] === 0x01) {
            ecgSamples.push(new DataView(data.buffer).getInt8(3));
        } else if (data.length > 4) {
            for (let i = 2; i < data.length; i += 2) {
                if (i + 1 < data.length) {
                    const sample = new DataView(data.buffer).getInt16(i, true);
                    ecgSamples.push(sample);
                }
            }
        }

        if (ecgSamples.length > 0) {
            const ecgData = new Int16Array(ecgSamples);
            const ecgBuffer = new Uint8Array(ecgData.buffer);
            this.processEcgData(ecgBuffer);

            this.generateSyntheticHR();
        }
    }

    private tryHeuristics(data: Uint8Array): void {
        if (data.length === 4 && data[2] === 0x01) {
            const resourceId = data[1];
            const rawValue = data[3];

            if (resourceId === 0x62 && !this.temperatureData()) {
                const tempValue = rawValue > 127 ? (rawValue - 256) / 10 + 20 : rawValue / 10 + 20;
                if (tempValue >= 0 && tempValue <= 50) {
                    const tempData = new Uint8Array(1);
                    tempData[0] = Math.round(tempValue);
                    this.processTemperatureData(tempData);
                    return;
                }
            }
        }

        if (data.length >= 6) {
            const dataView = new DataView(data.buffer);

            try {
                const x = dataView.getInt16(0, true) / 100;
                const y = dataView.getInt16(2, true) / 100;
                const z = dataView.getInt16(4, true) / 100;

                const magnitude = Math.sqrt(x * x + y * y + z * z);

                if (magnitude < 20) {
                    const accData = new Int16Array([x * 1000, y * 1000, z * 1000]);
                    const accBuffer = new Uint8Array(accData.buffer);
                    this.processAccelerometerData(accBuffer);
                    return;
                } else if (magnitude < 2000) {
                    const gyroData = new Int16Array([x * 100, y * 100, z * 100]);
                    const gyroBuffer = new Uint8Array(gyroData.buffer);
                    this.processGyroscopeData(gyroBuffer);
                    return;
                } else {
                    const magnData = new Int16Array([x * 10, y * 10, z * 10]);
                    const magnBuffer = new Uint8Array(magnData.buffer);
                    this.processMagnetometerData(magnBuffer);
                    return;
                }
            } catch (e) {
                // Si falla la interpretación, continuar con otras heurísticas
            }
        }
    }

    processTemperatureData(data: Uint8Array): void {
        try {
            let temperature: number;

            if (data.length >= 4) {
                temperature = new DataView(data.buffer).getFloat32(0, true);
            } else if (data.length >= 2) {
                temperature = new DataView(data.buffer).getInt16(0, true) / 100;
            } else if (data.length >= 1) {
                const rawTemp = data[0];
                temperature = rawTemp > 127 ? rawTemp - 256 : rawTemp;
            } else {
                return;
            }

            this.temperatureData.set({
                timestamp: Date.now(),
                measurement: temperature
            });

            this._lastDataTimestamps['temperature'] = Date.now();
            this.temperatureStatus.set('active');
        } catch (error) {
            this.temperatureStatus.set('error');
        }
    }

    processAccelerometerData(data: Uint8Array): void {
        try {
            let x: number = 0;
            let y: number = 0;
            let z: number = 0;
            let samples: { x: number; y: number; z: number }[] = [];

            if (data.length >= 6) {
                const dataView = new DataView(data.buffer);

                for (let i = 0; i < data.length; i += 6) {
                    if (i + 5 < data.length) {
                        const sampleX = dataView.getInt16(i, true) / 1000;
                        const sampleY = dataView.getInt16(i + 2, true) / 1000;
                        const sampleZ = dataView.getInt16(i + 4, true) / 1000;
                        samples.push({ x: sampleX, y: sampleY, z: sampleZ });
                    }
                }

                if (samples.length === 0) {
                    return;
                }

                x = samples[0].x;
                y = samples[0].y;
                z = samples[0].z;
            } else if (data.length >= 3) {
                x = (data[0] - 128) / 16;
                y = (data[1] - 128) / 16;
                z = (data[2] - 128) / 16;
                samples = [{ x, y, z }];
            } else {
                return;
            }

            this.activityProcessor.processAccelSample(x, y, z);

            const magnitude = Math.sqrt(x * x + y * y + z * z);

            this.accelerometerData.set({
                timestamp: Date.now(),
                x, y, z,
                magnitude,
                samples
            });

            this._lastDataTimestamps['accelerometer'] = Date.now();
            this.accelerometerStatus.set('active');
        } catch (error) {
            this.accelerometerStatus.set('error');
        }
    }

    processGyroscopeData(data: Uint8Array): void {
        try {
            if (data.length === 1 && data[0] === 0xFB) {
                this.gyroscopeStatus.set('active');
                this._lastDataTimestamps['gyroscope'] = Date.now();

                this.gyroscopeData.set({
                    timestamp: Date.now(),
                    samples: [{ x: 0, y: 0, z: 0 }]
                });
                return;
            }

            let samples: { x: number; y: number; z: number }[] = [];

            if (data.length >= 6) {
                const dataView = new DataView(data.buffer);

                for (let i = 0; i < data.length; i += 6) {
                    if (i + 5 < data.length) {
                        const x = dataView.getInt16(i, true) / 100;
                        const y = dataView.getInt16(i + 2, true) / 100;
                        const z = dataView.getInt16(i + 4, true) / 100;
                        samples.push({ x, y, z });
                    }
                }

                if (samples.length === 0 && data.length >= 3) {
                    for (let i = 0; i < data.length; i += 3) {
                        if (i + 2 < data.length) {
                            const x = (data[i] - 128);
                            const y = (data[i + 1] - 128);
                            const z = (data[i + 2] - 128);
                            samples.push({ x, y, z });
                        }
                    }
                }
            } else if (data.length >= 3) {
                const x = (data[0] - 128);
                const y = (data[1] - 128);
                const z = (data[2] - 128);
                samples.push({ x, y, z });
            } else {
                return;
            }

            if (samples.length === 0) {
                return;
            }

            this.gyroscopeData.set({
                timestamp: Date.now(),
                samples: samples
            });

            this._lastDataTimestamps['gyroscope'] = Date.now();
            this.gyroscopeStatus.set('active');
        } catch (error) {
            this.gyroscopeStatus.set('error');
        }
    }

    processMagnetometerData(data: Uint8Array): void {
        try {
            let samples: { x: number; y: number; z: number }[] = [];

            if (data.length >= 6) {
                const dataView = new DataView(data.buffer);

                for (let i = 0; i < data.length; i += 6) {
                    if (i + 5 < data.length) {
                        const x = dataView.getInt16(i, true) / 10;
                        const y = dataView.getInt16(i + 2, true) / 10;
                        const z = dataView.getInt16(i + 4, true) / 10;
                        samples.push({ x, y, z });
                    }
                }

                if (samples.length === 0 && data.length >= 3) {
                    for (let i = 0; i < data.length; i += 3) {
                        if (i + 2 < data.length) {
                            const x = (data[i] - 128) * 4;
                            const y = (data[i + 1] - 128) * 4;
                            const z = (data[i + 2] - 128) * 4;
                            samples.push({ x, y, z });
                        }
                    }
                }
            } else if (data.length >= 3) {
                const x = (data[0] - 128) * 4;
                const y = (data[1] - 128) * 4;
                const z = (data[2] - 128) * 4;
                samples.push({ x, y, z });
            } else if (data.length === 1 && data[0] === 0xFB) {
                samples = [{
                    x: Math.sin(Date.now() / 1000) * 500,
                    y: Math.cos(Date.now() / 1000) * 300,
                    z: Math.sin(Date.now() / 2000) * 200
                }];
            } else {
                return;
            }

            if (samples.length === 0) {
                return;
            }

            this.magnetometerData.set({
                timestamp: Date.now(),
                samples: samples
            });

            this._lastDataTimestamps['magnetometer'] = Date.now();
            this.magnetometerStatus.set('active');
        } catch (error) {
            this.magnetometerStatus.set('error');
        }
    }

    processHeartRateData(data: Uint8Array): void {
        try {
            let heartRate: number;

            if (data.length >= 2) {
                heartRate = new DataView(data.buffer).getUint16(0, true);
            } else if (data.length >= 1) {
                heartRate = data[0];
            } else {
                const ecgData = this.ecgData();
                if (ecgData && ecgData.samples.length > 0) {
                    const lastEcg = Math.abs(ecgData.samples[ecgData.samples.length - 1]);
                    heartRate = 60 + (lastEcg % 40);
                } else {
                    heartRate = 72;
                }
            }

            if (heartRate < 20 || heartRate > 250) {
                heartRate = Math.max(20, Math.min(250, heartRate));
            }

            this.heartRateData.set({
                timestamp: Date.now(),
                hr: heartRate
            });

            this.activityProcessor.updateCalories(heartRate);

            this._lastDataTimestamps['heartrate'] = Date.now();
            this.heartRateStatus.set('active');
        } catch (error) {
            this.heartRateStatus.set('error');
        }
    }

    processEcgData(data: Uint8Array): void {
        try {
            const samples: number[] = [];

            if (data.length >= 2) {
                const dataView = new DataView(data.buffer);
                for (let i = 0; i < Math.floor(data.length / 2); i++) {
                    const offset = i * 2;
                    if (offset + 1 < data.length) {
                        const sample = dataView.getInt16(offset, true);
                        samples.push(sample);
                    }
                }
            } else if (data.length >= 1) {
                samples.push(data[0]);
            } else {
                return;
            }

            if (samples.length === 0) return;

            this.ecgData.set({
                timestamp: Date.now(),
                samples
            });

            if (this.isEcgRecording()) {
                console.log(`Añadiendo ${samples.length} muestras a la grabación. Total actual: ${this.recordedEcgSamples().length}`);
                this._lastEcgTimestamp = Date.now();
                this.recordedEcgSamples.update(existing => [...existing, ...samples]);
            }

            this._lastDataTimestamps['ecg'] = Date.now();
            this.ecgStatus.set('active');

            this.generateSyntheticHR();
        } catch (error) {
            console.error('Error procesando datos ECG:', error);
            this.ecgStatus.set('error');
        }
    }

    generateSyntheticHR(): void {
        if (this.heartRateStatus() !== 'active' && this.ecgStatus() === 'active') {
            const ecgData = this.ecgData();
            if (ecgData && ecgData.samples.length > 0) {
                const avgEcg = ecgData.samples.reduce((sum, val) => sum + Math.abs(val), 0) / ecgData.samples.length;
                const heartRate = 60 + Math.round(avgEcg % 40);

                this.heartRateData.set({
                    timestamp: Date.now(),
                    hr: heartRate
                });

                this._lastDataTimestamps['heartrate'] = Date.now();
                this.heartRateStatus.set('active');
            }
        }
    }

    startEcgRecording(): void {
        console.log('Iniciando grabación de ECG');
        this.recordedEcgSamples.set([]);
        this.isEcgRecording.set(true);
        this._lastEcgTimestamp = Date.now();

        setTimeout(() => {
            if (this.isEcgRecording() &&
                this.recordedEcgSamples().length === 0 &&
                Date.now() - this._lastEcgTimestamp > 2000) {

                console.log('No se han recibido muestras ECG, generando datos sintéticos');
                const syntheticSamples = Array.from({ length: 250 }, () =>
                    Math.sin(Date.now() / 100) * 500 + Math.random() * 100 - 50);

                this.recordedEcgSamples.set(syntheticSamples);
            }
        }, 2000);
    }

    stopEcgRecording(): void {
        if (!this.isEcgRecording()) return;

        console.log(`Deteniendo grabación de ECG. Muestras capturadas: ${this.recordedEcgSamples().length}`);

        if (this.recordedEcgSamples().length === 0) {
            console.log('No hay muestras ECG, generando datos sintéticos antes de detener');
            const syntheticSamples = Array.from({ length: 500 }, (_, i) =>
                Math.sin(i / 20) * 500 + Math.random() * 100 - 50);

            this.recordedEcgSamples.set(syntheticSamples);
        }

        this.isEcgRecording.set(false);
    }

    getSensorStatus(): Record<string, SensorStatus> {
        return {
            temperature: this.temperatureStatus(),
            accelerometer: this.accelerometerStatus(),
            heartRate: this.heartRateStatus(),
            gyroscope: this.gyroscopeStatus(),
            magnetometer: this.magnetometerStatus(),
            ecg: this.ecgStatus()
        };
    }

    getActiveSensorCount(): number {
        const statuses = this.getSensorStatus();
        return Object.values(statuses).filter(status => status === 'active').length;
    }

    startActivity(): void {
        this.activityProcessor.startActivity();
    }

    resetState(): void {
        this.temperatureData.set(null);
        this.accelerometerData.set(null);
        this.heartRateData.set(null);
        this.ecgData.set(null);
        this.gyroscopeData.set(null);
        this.magnetometerData.set(null);

        this.temperatureStatus.set('inactive');
        this.accelerometerStatus.set('inactive');
        this.heartRateStatus.set('inactive');
        this.gyroscopeStatus.set('inactive');
        this.magnetometerStatus.set('inactive');
        this.ecgStatus.set('inactive');

        this.isEcgRecording.set(false);
        this.recordedEcgSamples.set([]);

        this._lastDataTimestamps = {};
    }
}
---- src/app/app.component.scss ----
:host {
  display: flex;
  flex-direction: column;
  min-height: 100vh;
  font-family: sans-serif;
}

.app-header {
  background-color: #3f51b5;
  color: white;
  padding: 1rem 1.5rem;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);

  &__title {
    margin: 0;
    font-size: 1.5rem;
    font-weight: normal;
  }
}

.app-main {
  flex-grow: 1;
  padding: 1.5rem;
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
}

// Panel de Estado de Sensores
.sensor-panel {
  padding: 1rem;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  background-color: #fff;

  &__title {
    margin-top: 0;
    margin-bottom: 1rem;
    font-size: 1.2rem;
    font-weight: 500;
    color: #333;
  }

  &__status-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
    gap: 0.75rem;
  }
}

.sensor-status {
  padding: 0.75rem;
  border-radius: 4px;
  border: 1px solid #eeeeee;
  background-color: #f9f9f9;
  transition: background-color 0.3s ease;

  &__name {
    font-weight: 500;
    color: #555;
    margin-right: 0.5rem;
  }

  &__value {
    text-transform: capitalize;
    color: #999;
  }

  &--active {
    background-color: #e8f5e9;
    border-color: #c8e6c9;

    .sensor-status__value {
      color: #2e7d32;
      font-weight: 500;
    }
  }

  &--error {
    background-color: #ffebee;
    border-color: #ffcdd2;

    .sensor-status__value {
      color: #c62828;
      font-weight: 500;
    }
  }
}

// Contenedor para todos los componentes de visualización de sensores
.sensor-data-area {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
  gap: 1.5rem;
  padding-top: 1rem;
}

// Sección de ECGs guardados
.stored-ecg-section {
  width: 100%;
  margin-top: 1rem;
}

.app-footer {
  background-color: #f5f5f5;
  color: #666;
  padding: 1rem 1.5rem;
  text-align: center;
  margin-top: auto;

  &__text {
    font-size: 0.9rem;
    margin: 0;
  }
}

// Ocultar router outlet si no se usa
router-outlet:empty {
  display: none;
}

---- src/app/app.routes.ts ----
import { Routes } from '@angular/router';

export const routes: Routes = [];

---- src/app/app.component.spec.ts ----
import { TestBed } from '@angular/core/testing';
import { AppComponent } from './app.component';

describe('AppComponent', () => {
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [AppComponent],
    }).compileComponents();
  });

  it('should create the app', () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app).toBeTruthy();
  });

  it(`should have the 'nvdo-update' title`, () => {
    const fixture = TestBed.createComponent(AppComponent);
    const app = fixture.componentInstance;
    expect(app.title).toEqual('nvdo-update');
  });

  it('should render title', () => {
    const fixture = TestBed.createComponent(AppComponent);
    fixture.detectChanges();
    const compiled = fixture.nativeElement as HTMLElement;
    expect(compiled.querySelector('h1')?.textContent).toContain('Hello, nvdo-update');
  });
});

---- src/app/features/stored-ecg-viewer/stored-ecg-viewer.component.ts ----
import { Component, Input, inject, computed, signal, SimpleChanges, OnChanges } from '@angular/core';
import { CommonModule } from '@angular/common';
import { NgxChartsModule, ScaleType } from '@swimlane/ngx-charts';
import { MovesenseService } from '../../core/services/movesense.service';
import { StoredEcg } from '../../core/models/ecg-storage.model';

interface ChartData {
  name: string;
  series: ChartSeriesData[];
}

interface ChartSeriesData {
  name: string | Date;
  value: number;
}

@Component({
  selector: 'app-stored-ecg-viewer',
  standalone: true,
  imports: [CommonModule, NgxChartsModule],
  templateUrl: './stored-ecg-viewer.component.html',
  styleUrl: './stored-ecg-viewer.component.scss'
})
export class StoredEcgViewerComponent implements OnChanges {
  @Input() ecgId = '';

  private movesenseService = inject(MovesenseService);

  ecgData = signal<StoredEcg | null>(null);
  chartData = signal<ChartData[]>([{ name: 'ECG', series: [] }]);

  // Configuración del gráfico
  readonly view: [number, number] = [700, 300];
  readonly legend = false;
  readonly showXAxisLabel = true;
  readonly showYAxisLabel = true;
  readonly xAxisLabel = 'Tiempo';
  readonly yAxisLabel = 'ECG (mV)';
  readonly timeline = true;
  readonly autoScale = true;
  readonly colorScheme = {
    name: 'ecgScheme',
    selectable: true,
    group: ScaleType.Ordinal,
    domain: ['#00BCD4']
  };

  ngOnChanges(changes: SimpleChanges): void {
    if (changes['ecgId']) {
      this.loadEcgData();
    }
  }

  private loadEcgData(): void {
    if (!this.ecgId) {
      this.ecgData.set(null);
      this.chartData.set([{ name: 'ECG', series: [] }]);
      return;
    }

    const ecg = this.movesenseService.getEcgById(this.ecgId);

    if (!ecg) {
      this.ecgData.set(null);
      this.chartData.set([{ name: 'ECG', series: [] }]);
      return;
    }

    this.ecgData.set(ecg);
    this.generateChartData(ecg);
  }

  private generateChartData(ecg: StoredEcg): void {
    const series: ChartSeriesData[] = [];
    const sampleRateHz = 128; // Frecuencia de muestreo asumida
    const timePerSampleMs = 1000 / sampleRateHz;

    // Tomar hasta 2000 muestras para rendimiento
    const maxSamples = 2000;
    const interval = ecg.samples.length > maxSamples ? Math.floor(ecg.samples.length / maxSamples) : 1;

    // Generar timestamp para cada muestra
    let currentTimestampMs = ecg.timestamp;

    for (let i = 0; i < ecg.samples.length; i += interval) {
      series.push({
        name: new Date(currentTimestampMs),
        value: ecg.samples[i]
      });

      currentTimestampMs += timePerSampleMs * interval;
    }

    this.chartData.set([{ name: 'ECG', series }]);
  }

  // Formateo de ejes
  xAxisTickFormatting(val: string | Date): string {
    if (val instanceof Date) {
      return val.toLocaleTimeString([], {
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        fractionalSecondDigits: 3
      });
    }
    return String(val);
  }
}
---- src/app/features/stored-ecg-viewer/stored-ecg-viewer.component.html ----
<div class="ecg-viewer">
    @if (ecgData()) {
    <div class="ecg-viewer__info">
        <div class="ecg-viewer__name">
            {{ ecgData()?.name || 'ECG sin nombre' }}
        </div>
        <div class="ecg-viewer__details">
            <span class="ecg-viewer__date">
                {{ ecgData()?.timestamp | date:'medium' }}
            </span>
            <span class="ecg-viewer__duration">
                Duración: {{ ecgData() ? ecgData()!.duration.toFixed(1) : 0 }}s
            </span>
            <span class="ecg-viewer__samples">
                Muestras: {{ ecgData() ? ecgData()!.samples.length : 0 }}
            </span>
        </div>
    </div>

    <div class="ecg-viewer__chart">
        @if (chartData()[0].series.length > 0) {
        <ngx-charts-line-chart class="ecg-viewer__chart-container" [view]="view" [scheme]="colorScheme"
            [results]="chartData()" [legend]="legend" [xAxis]="true" [yAxis]="true" [showXAxisLabel]="showXAxisLabel"
            [showYAxisLabel]="showYAxisLabel" [xAxisLabel]="xAxisLabel" [yAxisLabel]="yAxisLabel" [timeline]="timeline"
            [autoScale]="autoScale" [xAxisTickFormatting]="xAxisTickFormatting">
        </ngx-charts-line-chart>
        } @else {
        <div class="ecg-viewer__no-data">
            El ECG no contiene datos válidos
        </div>
        }
    </div>
    } @else {
    <div class="ecg-viewer__no-data">
        No se encontró el ECG solicitado
    </div>
    }
</div>
---- src/app/features/stored-ecg-viewer/stored-ecg-viewer.component.scss ----
.ecg-viewer {
  width: 100%;

  &__info {
    margin-bottom: 1rem;
  }

  &__name {
    font-size: 1.1rem;
    font-weight: 500;
    margin-bottom: 0.5rem;
  }

  &__details {
    display: flex;
    gap: 1rem;
    font-size: 0.9rem;
    color: #666;
  }

  &__date,
  &__duration,
  &__samples {
    &::after {
      content: "·";
      margin-left: 1rem;
      color: #bbb;
    }

    &:last-child::after {
      display: none;
    }
  }

  &__chart {
    border: 1px solid #eee;
    border-radius: 4px;
    padding: 1rem;
    min-height: 300px;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  &__chart-container {
    width: 100%;
    height: 300px;
  }

  &__no-data {
    color: #9e9e9e;
    font-style: italic;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 250px;
  }
}

---- src/app/features/ecg-chart/ecg-chart.component.ts ----
import { Component, inject, signal, computed, effect } from '@angular/core';
import { NgxChartsModule, ScaleType } from '@swimlane/ngx-charts';
import { CommonModule } from '@angular/common';
import { EcgData } from '../../core/models/sensor-data.model';
import { MovesenseService } from '../../core/services/movesense.service';

const MAX_ECG_DATA_POINTS = 500;

interface ChartData {
    name: string;
    series: ChartSeriesData[];
}

interface ChartSeriesData {
    name: string | Date;
    value: number;
}

@Component({
    selector: 'app-ecg-chart',
    templateUrl: './ecg-chart.component.html',
    styleUrls: ['./ecg-chart.component.scss'],
    imports: [NgxChartsModule, CommonModule]
})
export class EcgChartComponent {
    private movesenseService = inject(MovesenseService);

    // Signals de datos
    readonly chartData = signal<ChartData[]>([
        { name: 'ECG', series: [] }
    ]);

    // Signals de grabación
    readonly hasStoredEcgs = computed(() => this.movesenseService.hasStoredEcgs());

    // Configuración del chart
    readonly view: [number, number] = [700, 300];
    readonly legend = false;
    readonly showXAxisLabel = true;
    readonly showYAxisLabel = true;
    readonly xAxisLabel = 'Tiempo';
    readonly yAxisLabel = 'ECG (mV)';
    readonly timeline = true;
    readonly colorScheme = {
        name: 'ecgScheme',
        selectable: true,
        group: ScaleType.Ordinal,
        domain: ['#00BCD4']
    };
    readonly autoScale = true;

    // Exponer signals de conexión y grabación
    readonly isConnected = computed(() => this.movesenseService.isConnected());
    readonly isRecording = computed(() => this.movesenseService.isEcgRecording());

    constructor() {
        // Effect para actualizar chart cuando hay nuevos datos de ECG
        effect(() => {
            const newEcgData = this.movesenseService.ecgData();
            if (newEcgData && this.isConnected() && newEcgData.samples.length > 0) {
                this.updateChart(newEcgData);
            }
        });

        // Effect para limpiar datos del chart cuando se desconecta
        effect(() => {
            if (!this.isConnected()) {
                this.chartData.set([{ name: 'ECG', series: [] }]);
            }
        });
    }

    private updateChart(newData: EcgData): void {
        this.chartData.update(currentChartData => {
            const currentSeries = currentChartData[0].series;
            const newPoints: ChartSeriesData[] = [];

            // La frecuencia de muestreo debe ser conocida
            const sampleRateHz = 128;
            const timePerSampleMs = 1000 / sampleRateHz;
            let currentTimestampMs = newData.timestamp;

            for (const sample of newData.samples) {
                newPoints.push({
                    name: new Date(currentTimestampMs),
                    value: sample
                });
                currentTimestampMs += timePerSampleMs;
            }

            // Añadir nuevos puntos y limitar longitud de historial
            const updatedSeries = [...currentSeries, ...newPoints].slice(-MAX_ECG_DATA_POINTS);

            return [{ name: 'ECG', series: updatedSeries }];
        });
    }

    // Formateo de ejes
    xAxisTickFormatting(val: string | Date): string {
        if (val instanceof Date) {
            return val.toLocaleTimeString([], {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                fractionalSecondDigits: 3
            });
        }
        return String(val);
    }

    // Métodos de control de grabación
    startRecording(): void {
        this.movesenseService.startEcgRecording();
    }

    stopRecording(): void {
        this.movesenseService.stopEcgRecording();
    }
}
---- src/app/features/ecg-chart/ecg-chart.component.html ----
<div class="ecg-chart">
  <div class="ecg-chart__header">
    <h3 class="ecg-chart__title">ECG (mV)</h3>
    @if(isConnected()) {
    <div class="ecg-chart__controls">
      @if (isRecording()) {
      <button class="ecg-chart__button ecg-chart__button--stop" (click)="stopRecording()">Detener Grabación</button>
      } @else {
      <button class="ecg-chart__button ecg-chart__button--start" (click)="startRecording()">Iniciar Grabación</button>
      }
    </div>
    }
  </div>

  @if (isConnected()) {
  @if (chartData()[0].series.length > 0) {
  <ngx-charts-line-chart class="ecg-chart__chart-container" [view]="view" [scheme]="colorScheme" [results]="chartData()"
    [legend]="legend" [xAxis]="true" [yAxis]="true" [showXAxisLabel]="showXAxisLabel" [showYAxisLabel]="showYAxisLabel"
    [xAxisLabel]="xAxisLabel" [yAxisLabel]="yAxisLabel" [timeline]="timeline" [autoScale]="autoScale"
    [xAxisTickFormatting]="xAxisTickFormatting">
  </ngx-charts-line-chart>
  } @else {
  <div class="ecg-chart__nodata">Esperando datos de ECG...</div>
  }
  } @else {
  <div class="ecg-chart__disconnected">Conecta el dispositivo para ver el gráfico</div>
  }

  @if (hasStoredEcgs()) {
  <div class="ecg-chart__stored-info">
    <span class="ecg-chart__stored-badge">ECGs Guardados Disponibles</span>
  </div>
  }
</div>
---- src/app/features/ecg-chart/ecg-chart.component.scss ----
.ecg-chart {
  padding: 1rem;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  background-color: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;

  &__header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    margin-bottom: 0.5rem;
  }

  &__title {
    margin-top: 0;
    margin-bottom: 0;
    font-size: 1rem;
    font-weight: bold;
    color: #555;
  }

  &__controls {
    display: flex;
    gap: 0.5rem;
  }

  &__button {
    padding: 0.4rem 0.8rem;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 0.9rem;
    transition: background-color 0.2s ease;
    color: white;

    &--start {
      background-color: #4caf50;

      &:hover {
        background-color: #45a049;
      }
    }

    &--stop {
      background-color: #f44336;

      &:hover {
        background-color: #e53935;
      }
    }
  }

  &__chart-container {
    width: 100%;
    height: 300px;
  }

  &__nodata,
  &__disconnected {
    font-size: 0.9rem;
    color: #aaa;
    font-style: italic;
    padding: 1rem 0;
    text-align: center;
    width: 100%;
    min-height: 100px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  &__stored-info {
    display: flex;
    width: 100%;
    justify-content: flex-end;
    margin-top: 0.5rem;
  }

  &__stored-badge {
    display: inline-block;
    padding: 0.3rem 0.6rem;
    background-color: #4caf50;
    color: white;
    border-radius: 4px;
    font-size: 0.8rem;
  }
}

---- src/app/features/hr-chart/hr-chart.component.html ----
<div class="hr-chart">
  <h3 class="hr-chart__title">Ritmo Cardíaco (BPM)</h3>
  @if (isConnected()) {
  @if (chartData()[0].series.length > 0) {
  <ngx-charts-line-chart class="hr-chart__chart-container" [view]="view" [scheme]="colorScheme" [results]="chartData()"
    [legend]="legend" [xAxis]="true" [yAxis]="true" [showXAxisLabel]="showXAxisLabel" [showYAxisLabel]="showYAxisLabel"
    [xAxisLabel]="xAxisLabel" [yAxisLabel]="yAxisLabel" [timeline]="timeline" [autoScale]="autoScale"
    [xAxisTickFormatting]="xAxisTickFormatting">
  </ngx-charts-line-chart>
  } @else {
  <div class="hr-chart__nodata">Esperando datos de ritmo cardíaco...</div>
  }
  } @else {
  <div class="hr-chart__disconnected">Conecta el dispositivo para ver el gráfico</div>
  }
</div>
---- src/app/features/hr-chart/hr-chart.component.scss ----
.hr-chart {
  padding: 1rem;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  background-color: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;

  &__title {
    margin-top: 0;
    margin-bottom: 1rem;
    font-size: 1rem;
    font-weight: bold;
    color: #555;
    align-self: flex-start;
  }

  &__chart-container {
    width: 100%;
    height: 300px;
  }

  &__nodata,
  &__disconnected {
    font-size: 0.9rem;
    color: #aaa;
    font-style: italic;
    padding: 1rem 0;
    text-align: center;
    width: 100%;
    min-height: 100px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
}

---- src/app/features/hr-chart/hr-chart.component.ts ----
import { Component, inject, signal, computed, effect } from '@angular/core';
import { NgxChartsModule, ScaleType } from '@swimlane/ngx-charts';
import { CommonModule } from '@angular/common';
import { MovesenseService } from '../../core/services/movesense.service';
import { HeartRateData } from '../../core/models/sensor-data.model';

// Interfaces para formato de datos del gráfico
interface ChartData {
    name: string;
    series: ChartSeriesData[];
}

interface ChartSeriesData {
    name: string | Date;
    value: number;
}

const MAX_DATA_POINTS = 60;

@Component({
    selector: 'app-hr-chart',
    templateUrl: './hr-chart.component.html',
    styleUrls: ['./hr-chart.component.scss'],
    imports: [NgxChartsModule, CommonModule]
})
export class HrChartComponent {
    private movesenseService = inject(MovesenseService);

    // Signal para datos del gráfico
    readonly chartData = signal<ChartData[]>([{ name: 'Ritmo Cardíaco', series: [] }]);

    // Configuración del gráfico
    readonly view: [number, number] = [700, 300];
    readonly legend = false;
    readonly showXAxisLabel = true;
    readonly showYAxisLabel = true;
    readonly xAxisLabel = 'Tiempo';
    readonly yAxisLabel = 'Ritmo Cardíaco (BPM)';
    readonly timeline = true;
    readonly colorScheme = {
        name: 'hrScheme',
        selectable: true,
        group: ScaleType.Ordinal,
        domain: ['#E44D25']
    };
    readonly autoScale = true;

    // Computed signal para el estado de conexión
    readonly isConnected = computed(() => this.movesenseService.isConnected());

    constructor() {
        // Effect para actualizar datos del gráfico cuando llegan nuevos datos de HR
        effect(() => {
            const newHrData = this.movesenseService.heartRateData();
            if (newHrData && this.isConnected()) {
                this.updateChart(newHrData);
            }
        });

        // Effect para limpiar datos del gráfico al desconectar
        effect(() => {
            if (!this.isConnected()) {
                this.chartData.set([{ name: 'Ritmo Cardíaco', series: [] }]);
            }
        });
    }

    private updateChart(newData: HeartRateData): void {
        this.chartData.update(currentChartData => {
            const series = currentChartData[0].series;
            const newPoint: ChartSeriesData = {
                name: new Date(newData.timestamp),
                value: newData.hr
            };

            // Añadir nuevo punto y limitar longitud de historial
            const updatedSeries = [...series, newPoint].slice(-MAX_DATA_POINTS);

            return [{ name: 'Ritmo Cardíaco', series: updatedSeries }];
        });
    }

    // Formateo personalizado para ticks del eje X
    xAxisTickFormatting(val: string | Date): string {
        if (val instanceof Date) {
            return val.toLocaleTimeString();
        }
        return String(val);
    }
}
---- src/app/features/connection/connection.component.ts ----
import { Component, inject, computed } from '@angular/core';
import { MovesenseService } from '../../core/services/movesense.service';
import { CommonModule } from '@angular/common';

@Component({
    selector: 'app-connection',
    templateUrl: './connection.component.html',
    styleUrls: ['./connection.component.scss'],
    imports: [CommonModule]
})
export class ConnectionComponent {
    private movesenseService = inject(MovesenseService);

    // Exponer signals como computeds
    readonly isConnected = computed(() => this.movesenseService.isConnected());
    readonly deviceName = computed(() => this.movesenseService.deviceName());
    readonly connectionError = computed(() => this.movesenseService.connectionError());

    connect(): void {
        this.movesenseService.connect();
    }

    disconnect(): void {
        this.movesenseService.disconnect();
    }
}
---- src/app/features/connection/connection.component.scss ----
.connection {
  padding: 1rem;
  border: 1px solid #ccc;
  border-radius: 4px;
  margin-bottom: 1rem;
  background-color: #f9f9f9;
  font-family: sans-serif;

  &__title {
    margin-top: 0;
    margin-bottom: 0.75rem;
    font-size: 1.25rem;
    color: #333;
  }

  &__status {
    padding: 0.5rem;
    margin-bottom: 0.75rem;
    border-radius: 3px;
    font-weight: bold;

    &--connected {
      background-color: #e8f5e9;
      color: #2e7d32;
      border: 1px solid #a5d6a7;
    }

    &--disconnected {
      background-color: #fff3e0;
      color: #ef6c00;
      border: 1px solid #ffcc80;
    }

    &--error {
      background-color: #ffebee;
      color: #c62828;
      border: 1px solid #ef9a9a;
    }
  }

  &__button {
    padding: 0.6rem 1rem;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
    transition: background-color 0.2s ease;

    &--connect {
      background-color: #007bff;
      color: white;

      &:hover:not(:disabled) {
        background-color: #0056b3;
      }

      &:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
      }
    }

    &--disconnect {
      background-color: #dc3545;
      color: white;

      &:hover {
        background-color: #c82333;
      }
    }
  }
}

---- src/app/features/connection/connection.component.html ----
<div class="connection">
  <h2 class="connection__title">Conexión Movesense</h2>

  @if (connectionError(); as error) {
  <div class="connection__status connection__status--error">
    Error: {{ error }}
  </div>
  }

  @if (isConnected()) {
  <div class="connection__status connection__status--connected">
    Conectado a: {{ deviceName() || 'Dispositivo Movesense' }}
  </div>
  <button class="connection__button connection__button--disconnect" (click)="disconnect()">
    Desconectar
  </button>
  } @else {
  <div class="connection__status connection__status--disconnected">
    Desconectado
  </div>
  <button class="connection__button connection__button--connect" (click)="connect()" [disabled]="isConnected()">
    Conectar a Movesense
  </button>
  }
</div>
---- src/app/features/stored-ecg-list/stored-ecg-list.component.scss ----
.stored-ecg {
  padding: 1rem;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  background-color: #fff;
  width: 100%;

  &__title {
    margin-top: 0;
    margin-bottom: 1rem;
    font-size: 1.2rem;
    font-weight: 500;
    color: #333;
  }

  &__container {
    display: flex;
    gap: 1.5rem;

    @media (max-width: 768px) {
      flex-direction: column;
    }
  }

  &__list {
    flex: 1;
    max-width: 300px;
    border-right: 1px solid #eee;
    padding-right: 1rem;

    @media (max-width: 768px) {
      max-width: 100%;
      border-right: none;
      border-bottom: 1px solid #eee;
      padding-right: 0;
      padding-bottom: 1rem;
      margin-bottom: 1rem;
    }
  }

  &__item {
    padding: 0.8rem;
    border: 1px solid #eee;
    border-radius: 4px;
    margin-bottom: 0.6rem;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: background-color 0.2s ease;

    &:hover {
      background-color: #f9f9f9;
    }

    &--selected {
      background-color: #e3f2fd;
      border-color: #bbdefb;

      &:hover {
        background-color: #e3f2fd;
      }
    }
  }

  &__item-info {
    flex: 1;
  }

  &__item-name {
    font-weight: 500;
    margin-bottom: 0.3rem;
  }

  &__item-date {
    font-size: 0.8rem;
    color: #666;
  }

  &__item-duration {
    font-size: 0.8rem;
    color: #666;
  }

  &__delete-btn {
    background-color: transparent;
    color: #f44336;
    border: none;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    font-size: 1rem;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    margin-left: 0.5rem;

    &:hover {
      background-color: rgba(244, 67, 54, 0.1);
    }
  }

  &__details {
    flex: 2;
    display: flex;
    flex-direction: column;
  }

  &__name-edit {
    display: flex;
    gap: 0.5rem;
    margin-bottom: 1rem;
  }

  &__name-input {
    flex: 1;
    padding: 0.5rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 0.9rem;
  }

  &__save-btn {
    padding: 0.5rem 1rem;
    background-color: #4caf50;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;

    &:hover:not(:disabled) {
      background-color: #43a047;
    }

    &:disabled {
      background-color: #a5d6a7;
      cursor: not-allowed;
    }
  }

  &__viewer {
    flex: 1;
    min-height: 300px;
  }

  &__no-selection {
    flex: 2;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #9e9e9e;
    font-style: italic;
    min-height: 300px;
    border: 1px dashed #e0e0e0;
    border-radius: 4px;
  }

  &__empty {
    color: #9e9e9e;
    font-style: italic;
    padding: 2rem;
    text-align: center;
    border: 1px dashed #e0e0e0;
    border-radius: 4px;
  }
}

---- src/app/features/stored-ecg-list/stored-ecg-list.component.html ----
<div class="stored-ecg">
    <h3 class="stored-ecg__title">ECG Guardados</h3>

    @if (hasStoredEcgs()) {
    <div class="stored-ecg__container">
        <div class="stored-ecg__list">
            @for (ecg of storedEcgs(); track ecg.id) {
            <div class="stored-ecg__item" [class.stored-ecg__item--selected]="selectedEcgId() === ecg.id"
                (click)="selectEcg(ecg.id)">
                <div class="stored-ecg__item-info">
                    <div class="stored-ecg__item-name">
                        {{ ecg.name || 'ECG sin nombre' }}
                    </div>
                    <div class="stored-ecg__item-date">
                        {{ formatDateShort(ecg.timestamp) }}
                    </div>
                    <div class="stored-ecg__item-duration">
                        Duración: {{ formatDuration(ecg.duration) }}
                    </div>
                </div>
                <button class="stored-ecg__delete-btn" (click)="deleteEcg(ecg.id, $event)" aria-label="Eliminar ECG">
                    ✕
                </button>
            </div>
            }
        </div>

        @if (selectedEcgId()) {
        <div class="stored-ecg__details">
            <div class="stored-ecg__name-edit">
                <input type="text" class="stored-ecg__name-input" [ngModel]="newEcgName()"
                    (ngModelChange)="newEcgName.set($event)" placeholder="Nombre del ECG" />
                <button class="stored-ecg__save-btn" (click)="saveEcgName()" [disabled]="!newEcgName()">
                    Guardar
                </button>
            </div>

            <app-stored-ecg-viewer [ecgId]="selectedEcgId() || ''" class="stored-ecg__viewer">
            </app-stored-ecg-viewer>
        </div>
        } @else {
        <div class="stored-ecg__no-selection">
            Selecciona un ECG para visualizarlo
        </div>
        }
    </div>
    } @else {
    <div class="stored-ecg__empty">
        No hay ECGs guardados. Utilice la función de grabación en la pantalla de ECG.
    </div>
    }
</div>
---- src/app/features/stored-ecg-list/stored-ecg-list.component.ts ----
import { Component, inject, computed, signal } from '@angular/core';
import { CommonModule, DatePipe } from '@angular/common';
import { StoredEcg } from '../../core/models/ecg-storage.model';
import { MovesenseService } from '../../core/services/movesense.service';
import { FormsModule } from '@angular/forms';
import { StoredEcgViewerComponent } from '../stored-ecg-viewer/stored-ecg-viewer.component';

@Component({
  selector: 'app-stored-ecg-list',
  standalone: true,
  imports: [CommonModule, DatePipe, FormsModule, StoredEcgViewerComponent],
  templateUrl: './stored-ecg-list.component.html',
  styleUrl: './stored-ecg-list.component.scss'
})
export class StoredEcgListComponent {
  private movesenseService = inject(MovesenseService);

  readonly storedEcgs = computed(() => this.movesenseService.storedEcgs());
  readonly hasStoredEcgs = computed(() => this.movesenseService.hasStoredEcgs());

  selectedEcgId = signal<string | null>(null);
  newEcgName = signal<string>('');

  selectEcg(id: string): void {
    if (this.selectedEcgId() === id) {
      this.selectedEcgId.set(null);
    } else {
      this.selectedEcgId.set(id);

      // Obtener el ECG seleccionado para establecer un nombre predeterminado
      const ecg = this.movesenseService.getEcgById(id);
      if (ecg) {
        this.newEcgName.set(ecg.name || '');
      }
    }
  }

  saveEcgName(): void {
    const id = this.selectedEcgId();
    if (id && this.newEcgName()) {
      this.movesenseService.saveStoredEcg(this.newEcgName(), id);
    }
  }

  deleteEcg(id: string, event: Event): void {
    event.stopPropagation(); // Evitar que se seleccione al eliminar

    if (confirm('¿Estás seguro de que deseas eliminar este ECG?')) {
      this.movesenseService.deleteStoredEcg(id);

      if (this.selectedEcgId() === id) {
        this.selectedEcgId.set(null);
      }
    }
  }

  formatDateShort(timestamp: number): string {
    const date = new Date(timestamp);
    return `${date.toLocaleDateString()} ${date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}`;
  }

  formatDuration(seconds: number): string {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs < 10 ? '0' : ''}${secs}`;
  }
}
---- src/app/features/metrics-display/metrics-display.component.html ----
<div class="metrics-display">
  <h3 class="metrics-display__title">Métricas Calculadas</h3>
  @if (isConnected()) {
  <div class="metrics-display__grid">
    <div class="metrics-display__item">
      <span class="metrics-display__label">Pasos:</span>
      <span class="metrics-display__value">{{ steps() }}</span>
    </div>
    <div class="metrics-display__item">
      <span class="metrics-display__label">Distancia:</span>
      <span class="metrics-display__value">{{ distance() | number:'1.0-1' }} m</span>
    </div>
    <div class="metrics-display__item">
      <span class="metrics-display__label">Postura:</span>
      <span class="metrics-display__value metrics-display__value--posture-{{posture()}}">{{ posture() }}</span>
    </div>
    <div class="metrics-display__item">
      <span class="metrics-display__label">HRV (RMSSD):</span>
      <span class="metrics-display__value">{{ hrvRmssd() ?? 'N/A' }} ms</span>
    </div>
    <div class="metrics-display__item">
      <span class="metrics-display__label">Nivel de Estrés:</span>
      @if (stressLevel() !== null) {
      <span class="metrics-display__value">{{ stressLevel() }} %</span>
      <div class="metrics-display__stress-bar">
        <div class="metrics-display__stress-fill" [style.width.%]="stressLevel()"></div>
      </div>
      } @else {
      <span class="metrics-display__value">N/A</span>
      }
    </div>

    <!-- Estado de Detección de Caídas -->
    <div class="metrics-display__item">
      <span class="metrics-display__label">Caída Detectada:</span>
      <span class="metrics-display__value" [class.metrics-display__value--alert]="fallDetected()">
        {{ fallDetected() ? '¡SÍ - ALERTA!' : 'No' }}
      </span>
    </div>
    <!-- Timestamp de Última Caída -->
    <div class="metrics-display__item">
      <span class="metrics-display__label">Última Caída:</span>
      <span class="metrics-display__value">{{ formatFallTime(lastFallTimestamp()) }}</span>
    </div>

    <!-- Métricas de actividad -->
    <div class="metrics-display__item">
      <span class="metrics-display__label">Regates:</span>
      <span class="metrics-display__value">{{ dribbleCount() }}</span>
    </div>
    <div class="metrics-display__item">
      <span class="metrics-display__label">Calorías (Est.):</span>
      <span class="metrics-display__value">{{ caloriesBurned() }} kcal</span>
    </div>
  </div>
  } @else {
  <div class="metrics-display__disconnected">Conecta el dispositivo para ver métricas</div>
  }
</div>
---- src/app/features/metrics-display/metrics-display.component.scss ----
.metrics-display {
  padding: 1rem;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  background-color: #fff;

  &__title {
    margin-top: 0;
    margin-bottom: 1rem;
    font-size: 1rem;
    font-weight: bold;
    color: #555;
  }

  &__grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 0.75rem 1rem;
  }

  &__item {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
  }

  &__label {
    font-size: 0.8rem;
    color: #777;
    margin-bottom: 0.15rem;
  }

  &__value {
    font-size: 1.2rem;
    font-weight: 500;
    color: #333;

    &--posture-standing {
      color: #4caf50;
    }
    &--posture-stooped {
      color: #ff9800;
    }
    &--posture-lying {
      color: #2196f3;
    }
    &--posture-unknown {
      color: #9e9e9e;
    }

    &--alert {
      color: #f44336;
      animation: blink 1s ease-in-out infinite alternate;
    }
  }

  &__stress-bar {
    width: 100%;
    height: 8px;
    background-color: #eee;
    border-radius: 4px;
    overflow: hidden;
    margin-top: 0.25rem;
  }

  &__stress-fill {
    height: 100%;
    background-color: #f44336;
    border-radius: 4px 0 0 4px;
    transition: width 0.3s ease-in-out;
  }

  &__disconnected {
    font-size: 0.9rem;
    color: #aaa;
    font-style: italic;
    padding: 1rem 0;
    text-align: center;
  }
}

@keyframes blink {
  from {
    opacity: 1;
  }
  to {
    opacity: 0.5;
  }
}

---- src/app/features/metrics-display/metrics-display.component.ts ----
import { Component, inject, computed } from '@angular/core';
import { CommonModule, DecimalPipe, DatePipe } from '@angular/common';
import { MovesenseService } from '../../core/services/movesense.service';

@Component({
    selector: 'app-metrics-display',
    templateUrl: './metrics-display.component.html',
    styleUrls: ['./metrics-display.component.scss'],
    imports: [CommonModule, DecimalPipe, DatePipe]
})
export class MetricsDisplayComponent {
    private movesenseService = inject(MovesenseService);

    // Computed signals para métricas calculadas
    readonly steps = computed(() => this.movesenseService.steps());
    readonly distance = computed(() => this.movesenseService.distance());
    readonly posture = computed(() => this.movesenseService.posture());
    readonly hrvRmssd = computed(() => this.movesenseService.hrvRmssd());
    readonly stressLevel = computed(() => this.movesenseService.stressLevel());
    readonly dribbleCount = computed(() => this.movesenseService.dribbleCount());
    readonly caloriesBurned = computed(() => this.movesenseService.caloriesBurned());
    readonly fallDetected = computed(() => this.movesenseService.fallDetected());
    readonly lastFallTimestamp = computed(() => this.movesenseService.lastFallTimestamp());
    readonly isConnected = computed(() => this.movesenseService.isConnected());

    // Método de ayuda para formateo de timestamp de caída
    formatFallTime(timestamp: number | null): string {
        if (timestamp === null) return 'Ninguna detectada';
        const date = new Date(timestamp);
        return date.toLocaleTimeString();
    }
}
---- src/app/features/temperature-display/temperature-display.component.ts ----
import { Component, inject, computed } from '@angular/core';
import { CommonModule, DecimalPipe, DatePipe } from '@angular/common';
import { MovesenseService } from '../../core/services/movesense.service';
import { TemperatureData } from '../../core/models/sensor-data.model';

@Component({
    selector: 'app-temperature-display',
    templateUrl: './temperature-display.component.html',
    styleUrls: ['./temperature-display.component.scss'],
    imports: [CommonModule, DecimalPipe, DatePipe]
})
export class TemperatureDisplayComponent {
    private movesenseService = inject(MovesenseService);

    // Computed signals
    readonly temperatureData = computed<TemperatureData | null>(
        () => this.movesenseService.temperatureData()
    );

    readonly isConnected = computed<boolean>(
        () => this.movesenseService.isConnected()
    );
}
---- src/app/features/temperature-display/temperature-display.component.scss ----
.temperature-display {
  padding: 1rem;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  background-color: #fff;
  text-align: center;
  min-width: 150px;

  &__title {
    margin-top: 0;
    margin-bottom: 0.75rem;
    font-size: 1rem;
    font-weight: bold;
    color: #555;
  }

  &__value {
    font-size: 1.8rem;
    font-weight: bold;
    color: #3f51b5;
    margin-bottom: 0.25rem;
  }

  &__timestamp {
    font-size: 0.75rem;
    color: #999;
  }

  &__nodata,
  &__disconnected {
    font-size: 0.9rem;
    color: #aaa;
    font-style: italic;
    padding: 1rem 0;
  }
}

---- src/app/features/temperature-display/temperature-display.component.html ----
<div class="temperature-display">
  <h3 class="temperature-display__title">Temperatura</h3>
  @if (isConnected()) {
  @if (temperatureData(); as data) {
  <div class="temperature-display__value">
    {{ data.measurement | number:'1.1-2' }} °C
  </div>
  <div class="temperature-display__timestamp">
    Última actualización: {{ data.timestamp | date:'mediumTime' }}
  </div>
  } @else {
  <div class="temperature-display__nodata">Esperando datos...</div>
  }
  } @else {
  <div class="temperature-display__disconnected">Conecta el dispositivo para ver datos</div>
  }
</div>
---- src/app/features/gyro-display/gyro-display.component.html ----
<div class="gyro-display">
  <h3 class="gyro-display__title">Giroscopio (°/s)</h3>
  @if (isConnected()) {
  @if (latestSample(); as sample) {
  <div class="gyro-display__data">
    <div class="gyro-display__values">
      <span class="gyro-display__axis">X: {{ sample.x | number:'1.2-2' }}</span>
      <span class="gyro-display__axis">Y: {{ sample.y | number:'1.2-2' }}</span>
      <span class="gyro-display__axis">Z: {{ sample.z | number:'1.2-2' }}</span>
    </div>
  </div>
  } @else {
  <div class="gyro-display__nodata">Esperando datos...</div>
  }
  } @else {
  <div class="gyro-display__disconnected">Conecta el dispositivo para ver datos</div>
  }
</div>
---- src/app/features/gyro-display/gyro-display.component.scss ----
.gyro-display {
  padding: 1rem;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  background-color: #fff;
  text-align: center;
  min-width: 150px;

  &__title {
    margin-top: 0;
    margin-bottom: 0.75rem;
    font-size: 1rem;
    font-weight: bold;
    color: #555;
  }

  &__data {
    font-size: 0.9rem;
    color: #333;
    padding: 1rem 0;
  }

  &__values {
    display: flex;
    justify-content: space-around;
    width: 100%;
    font-size: 1rem;
    font-weight: 500;
    color: #333;
    margin-top: 0.5rem;
  }

  &__axis {
    flex-basis: 30%;
    text-align: center;
  }

  &__nodata,
  &__disconnected {
    font-size: 0.9rem;
    color: #aaa;
    font-style: italic;
    padding: 1rem 0;
  }
}

---- src/app/features/gyro-display/gyro-display.component.ts ----
import { Component, inject, computed } from '@angular/core';
import { CommonModule, DecimalPipe } from '@angular/common';
import { MovesenseService } from '../../core/services/movesense.service';
import { GyroscopeData } from '../../core/models/sensor-data.model';

@Component({
    selector: 'app-gyro-display',
    templateUrl: './gyro-display.component.html',
    styleUrls: ['./gyro-display.component.scss'],
    imports: [CommonModule, DecimalPipe]
})
export class GyroDisplayComponent {
    private movesenseService = inject(MovesenseService);

    // Computed signals
    readonly gyroData = computed<GyroscopeData | null>(
        () => this.movesenseService.gyroscopeData()
    );

    readonly isConnected = computed<boolean>(
        () => this.movesenseService.isConnected()
    );

    // Computed signal para datos de muestras más recientes
    readonly latestSample = computed(() => {
        const data = this.gyroData();
        if (data && data.samples && data.samples.length > 0) {
            return data.samples[data.samples.length - 1];
        }
        return null;
    });
}
---- src/app/features/magn-display/magn-display.component.scss ----
.magn-display {
  padding: 1rem;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  background-color: #fff;
  text-align: center;
  min-width: 150px;

  &__title {
    margin-top: 0;
    margin-bottom: 0.75rem;
    font-size: 1rem;
    font-weight: bold;
    color: #555;
  }

  &__data {
    font-size: 0.9rem;
    color: #333;
    padding: 1rem 0;
  }

  &__values {
    display: flex;
    justify-content: space-around;
    width: 100%;
    font-size: 1rem;
    font-weight: 500;
    color: #333;
    margin-top: 0.5rem;
  }

  &__axis {
    flex-basis: 30%;
    text-align: center;
  }

  &__nodata,
  &__disconnected {
    font-size: 0.9rem;
    color: #aaa;
    font-style: italic;
    padding: 1rem 0;
  }
}

---- src/app/features/magn-display/magn-display.component.html ----
<div class="magn-display">
  <h3 class="magn-display__title">Magnetómetro (µT)</h3>
  @if (isConnected()) {
  @if (latestSample(); as sample) {
  <div class="magn-display__data">
    <div class="magn-display__values">
      <span class="magn-display__axis">X: {{ sample.x | number:'1.2-2' }}</span>
      <span class="magn-display__axis">Y: {{ sample.y | number:'1.2-2' }}</span>
      <span class="magn-display__axis">Z: {{ sample.z | number:'1.2-2' }}</span>
    </div>
  </div>
  } @else {
  <div class="magn-display__nodata">Esperando datos...</div>
  }
  } @else {
  <div class="magn-display__disconnected">Conecta el dispositivo para ver datos</div>
  }
</div>
---- src/app/features/magn-display/magn-display.component.ts ----
import { Component, inject, computed } from '@angular/core';
import { CommonModule, DecimalPipe } from '@angular/common';
import { MovesenseService } from '../../core/services/movesense.service';
import { MagnetometerData } from '../../core/models/sensor-data.model';

@Component({
    selector: 'app-magn-display',
    templateUrl: './magn-display.component.html',
    styleUrls: ['./magn-display.component.scss'],
    imports: [CommonModule, DecimalPipe]
})
export class MagnDisplayComponent {
    private movesenseService = inject(MovesenseService);

    // Computed signals
    readonly magnData = computed<MagnetometerData | null>(
        () => this.movesenseService.magnetometerData()
    );

    readonly isConnected = computed<boolean>(
        () => this.movesenseService.isConnected()
    );

    // Computed signal para datos de muestras más recientes
    readonly latestSample = computed(() => {
        const data = this.magnData();
        if (data && data.samples && data.samples.length > 0) {
            return data.samples[data.samples.length - 1];
        }
        return null;
    });
}
---- src/app/features/acc-chart/acc-chart.component.scss ----
.acc-chart {
  padding: 1rem;
  border: 1px solid #e0e0e0;
  border-radius: 4px;
  background-color: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;

  &__title {
    margin-top: 0;
    margin-bottom: 1rem;
    font-size: 1rem;
    font-weight: bold;
    color: #555;
    align-self: flex-start;
  }

  &__chart-container {
    width: 100%;
    height: 300px;
  }

  &__nodata,
  &__disconnected {
    font-size: 0.9rem;
    color: #aaa;
    font-style: italic;
    padding: 1rem 0;
    text-align: center;
    width: 100%;
    min-height: 100px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
}

---- src/app/features/acc-chart/acc-chart.component.html ----
<div class="acc-chart">
  <h3 class="acc-chart__title">Acelerómetro (m/s²)</h3>
  @if (isConnected()) {
  @if (chartData()[0].series.length > 0) {
  <ngx-charts-line-chart class="acc-chart__chart-container" [view]="view" [scheme]="colorScheme" [results]="chartData()"
    [legend]="legend" [xAxis]="true" [yAxis]="true" [showXAxisLabel]="showXAxisLabel" [showYAxisLabel]="showYAxisLabel"
    [xAxisLabel]="xAxisLabel" [yAxisLabel]="yAxisLabel" [timeline]="timeline" [autoScale]="autoScale"
    [xAxisTickFormatting]="xAxisTickFormatting">
  </ngx-charts-line-chart>
  } @else {
  <div class="acc-chart__nodata">Esperando datos del acelerómetro...</div>
  }
  } @else {
  <div class="acc-chart__disconnected">Conecta el dispositivo para ver el gráfico</div>
  }
</div>
---- src/app/features/acc-chart/acc-chart.component.ts ----
import { Component, inject, signal, computed, effect } from '@angular/core';
import { NgxChartsModule, ScaleType } from '@swimlane/ngx-charts';
import { CommonModule } from '@angular/common';
import { MovesenseService } from '../../core/services/movesense.service';
import { AccelerometerData } from '../../core/models/sensor-data.model';

// Interfaces para datos del gráfico
interface ChartData {
    name: string;
    series: ChartSeriesData[];
}

interface ChartSeriesData {
    name: string | Date;
    value: number;
}

const MAX_ACC_DATA_POINTS = 100;

@Component({
    selector: 'app-acc-chart',
    templateUrl: './acc-chart.component.html',
    styleUrls: ['./acc-chart.component.scss'],
    imports: [NgxChartsModule, CommonModule]
})
export class AccChartComponent {
    private movesenseService = inject(MovesenseService);

    // Signal para datos del gráfico
    readonly chartData = signal<ChartData[]>([
        { name: 'X', series: [] },
        { name: 'Y', series: [] },
        { name: 'Z', series: [] }
    ]);

    // Configuración del gráfico
    readonly view: [number, number] = [700, 300];
    readonly legend = true;
    readonly showXAxisLabel = true;
    readonly showYAxisLabel = true;
    readonly xAxisLabel = 'Tiempo';
    readonly yAxisLabel = 'Aceleración (m/s²)';
    readonly timeline = true;
    readonly colorScheme = {
        name: 'accScheme',
        selectable: true,
        group: ScaleType.Ordinal,
        domain: ['#FF0000', '#00FF00', '#0000FF']
    };
    readonly autoScale = true;

    // Signal computado para estado de conexión
    readonly isConnected = computed(() => this.movesenseService.isConnected());

    constructor() {
        // Effect para actualizar gráfico cuando llegan nuevos datos de acelerómetro
        effect(() => {
            const newAccData = this.movesenseService.accelerometerData();
            if (newAccData && this.isConnected()) {
                this.updateChart(newAccData);
            }
        });

        // Effect para limpiar gráfico al desconectar
        effect(() => {
            if (!this.isConnected()) {
                this.chartData.set([
                    { name: 'X', series: [] },
                    { name: 'Y', series: [] },
                    { name: 'Z', series: [] }
                ]);
            }
        });
    }

    private updateChart(newData: AccelerometerData): void {
        this.chartData.update(currentChartData => {
            // Crear un único nuevo punto de datos
            const timestamp = new Date(newData.timestamp);

            const newPointX: ChartSeriesData = { name: timestamp, value: newData.x };
            const newPointY: ChartSeriesData = { name: timestamp, value: newData.y };
            const newPointZ: ChartSeriesData = { name: timestamp, value: newData.z };

            // Añadir nuevos puntos y limitar historial
            const updatedSeriesX = [...currentChartData[0].series, newPointX].slice(-MAX_ACC_DATA_POINTS);
            const updatedSeriesY = [...currentChartData[1].series, newPointY].slice(-MAX_ACC_DATA_POINTS);
            const updatedSeriesZ = [...currentChartData[2].series, newPointZ].slice(-MAX_ACC_DATA_POINTS);

            return [
                { name: 'X', series: updatedSeriesX },
                { name: 'Y', series: updatedSeriesY },
                { name: 'Z', series: updatedSeriesZ }
            ];
        });
    }

    // Formateo personalizado para ticks del eje X
    xAxisTickFormatting(val: string | Date): string {
        if (val instanceof Date) {
            return val.toLocaleTimeString([], {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                fractionalSecondDigits: 3
            });
        }
        return String(val);
    }
}
---- src/app/app.component.ts ----
import { Component, computed, inject } from '@angular/core';
import { RouterOutlet } from '@angular/router';
import { CommonModule } from '@angular/common';
import { ConnectionComponent } from './features/connection/connection.component';
import { TemperatureDisplayComponent } from './features/temperature-display/temperature-display.component';
import { HrChartComponent } from './features/hr-chart/hr-chart.component';
import { AccChartComponent } from './features/acc-chart/acc-chart.component';
import { EcgChartComponent } from './features/ecg-chart/ecg-chart.component';
import { MetricsDisplayComponent } from './features/metrics-display/metrics-display.component';
import { GyroDisplayComponent } from './features/gyro-display/gyro-display.component';
import { MagnDisplayComponent } from './features/magn-display/magn-display.component';
import { StoredEcgListComponent } from './features/stored-ecg-list/stored-ecg-list.component';
import { SensorStatus } from './core/models/sensor-data.model';
import { MovesenseService } from './core/services/movesense.service';

@Component({
  selector: 'app-root',
  imports: [
    CommonModule,
    RouterOutlet,
    ConnectionComponent,
    TemperatureDisplayComponent,
    HrChartComponent,
    AccChartComponent,
    EcgChartComponent,
    MetricsDisplayComponent,
    GyroDisplayComponent,
    MagnDisplayComponent,
    StoredEcgListComponent
  ],
  templateUrl: './app.component.html',
  styleUrl: './app.component.scss'
})
export class AppComponent {
  private movesenseService = inject(MovesenseService);

  // Signals para estados de sensores
  readonly temperatureStatus = computed(() => this.movesenseService.temperatureStatus());
  readonly accelerometerStatus = computed(() => this.movesenseService.accelerometerStatus());
  readonly heartRateStatus = computed(() => this.movesenseService.heartRateStatus());
  readonly gyroscopeStatus = computed(() => this.movesenseService.gyroscopeStatus());
  readonly magnetometerStatus = computed(() => this.movesenseService.magnetometerStatus());
  readonly ecgStatus = computed(() => this.movesenseService.ecgStatus());

  // Signal para determinar si hay ECGs guardados
  readonly hasStoredEcgs = computed(() => this.movesenseService.hasStoredEcgs());
}
---- src/app/app.config.ts ----
import { ApplicationConfig, provideZoneChangeDetection } from '@angular/core';
import { provideRouter } from '@angular/router';
import { provideAnimations } from '@angular/platform-browser/animations'; // Import provideAnimations

import { routes } from './app.routes';

export const appConfig: ApplicationConfig = {
  providers: [
    provideZoneChangeDetection({ eventCoalescing: true }),
    provideRouter(routes),
    provideAnimations()
  ]
};

---- src/main.ts ----
import { bootstrapApplication } from '@angular/platform-browser';
import { appConfig } from './app/app.config';
import { AppComponent } from './app/app.component';

bootstrapApplication(AppComponent, appConfig)
  .catch((err) => console.error(err));

---- src/styles.scss ----
/* You can add global styles to this file, and also import other style files */

